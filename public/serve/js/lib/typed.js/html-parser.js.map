{"version":3,"sources":["lib/typed.js/html-parser.js"],"names":["HTMLParser","curString","curStrPos","self","contentType","curChar","substr","charAt","endTag","length","htmlParser"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAMqBA,U;;;;;;;oCAULC,S,EAAWC,S,EAAWC,I,EAAM;AACxC,YAAIA,KAAKC,WAAL,KAAqB,MAAzB,EAAiC,OAAOF,SAAP;AACjC,YAAMG,UAAUJ,UAAUK,MAAV,CAAiBJ,SAAjB,EAA4BK,MAA5B,CAAmC,CAAnC,CAAhB;AACA,YAAIF,YAAY,GAAZ,IAAmBA,YAAY,GAAnC,EAAwC;AACtC,cAAIG,SAAS,EAAb;AACA,cAAIH,YAAY,GAAhB,EAAqB;AACnBG,qBAAS,GAAT;AACD,WAFD,MAEO;AACLA,qBAAS,GAAT;AACD;AACD,iBAAOP,UAAUK,MAAV,CAAiBJ,YAAY,CAA7B,EAAgCK,MAAhC,CAAuC,CAAvC,MAA8CC,MAArD,EAA6D;AAC3DN;AACA,gBAAIA,YAAY,CAAZ,GAAgBD,UAAUQ,MAA9B,EAAsC;AACpC;AACD;AACF;AACDP;AACD;AACD,eAAOA,SAAP;AACD;;;yCAUkBD,S,EAAWC,S,EAAWC,I,EAAM;AAC7C,YAAIA,KAAKC,WAAL,KAAqB,MAAzB,EAAiC,OAAOF,SAAP;AACjC,YAAMG,UAAUJ,UAAUK,MAAV,CAAiBJ,SAAjB,EAA4BK,MAA5B,CAAmC,CAAnC,CAAhB;AACA,YAAIF,YAAY,GAAZ,IAAmBA,YAAY,GAAnC,EAAwC;AACtC,cAAIG,SAAS,EAAb;AACA,cAAIH,YAAY,GAAhB,EAAqB;AACnBG,qBAAS,GAAT;AACD,WAFD,MAEO;AACLA,qBAAS,GAAT;AACD;AACD,iBAAOP,UAAUK,MAAV,CAAiBJ,YAAY,CAA7B,EAAgCK,MAAhC,CAAuC,CAAvC,MAA8CC,MAArD,EAA6D;AAC3DN;AACA,gBAAIA,YAAY,CAAhB,EAAmB;AACjB;AACD;AACF;AACDA;AACD;AACD,eAAOA,SAAP;AACD;;;;;;oBA1DkBF,U;AA6Dd,MAAIU,kCAAa,IAAIV,UAAJ,EAAjB","file":"html-parser.js","sourcesContent":["\n/**\n * TODO: These methods can probably be combined somehow\n * Parse HTML tags & HTML Characters\n */\n\nexport default class HTMLParser {\n  /**\n   * Type HTML tags & HTML Characters\n   * @param {string} curString Current string\n   * @param {number} curStrPos Position in current string\n   * @param {Typed} self instance of Typed\n   * @returns {number} a new string position\n   * @private\n   */\n\n  typeHtmlChars(curString, curStrPos, self) {\n    if (self.contentType !== 'html') return curStrPos;\n    const curChar = curString.substr(curStrPos).charAt(0);\n    if (curChar === '<' || curChar === '&') {\n      let endTag = '';\n      if (curChar === '<') {\n        endTag = '>';\n      } else {\n        endTag = ';';\n      }\n      while (curString.substr(curStrPos + 1).charAt(0) !== endTag) {\n        curStrPos++;\n        if (curStrPos + 1 > curString.length) {\n          break;\n        }\n      }\n      curStrPos++;\n    }\n    return curStrPos;\n  }\n\n  /**\n   * Backspace HTML tags and HTML Characters\n   * @param {string} curString Current string\n   * @param {number} curStrPos Position in current string\n   * @param {Typed} self instance of Typed\n   * @returns {number} a new string position\n   * @private\n   */\n  backSpaceHtmlChars(curString, curStrPos, self) {\n    if (self.contentType !== 'html') return curStrPos;\n    const curChar = curString.substr(curStrPos).charAt(0);\n    if (curChar === '>' || curChar === ';') {\n      let endTag = '';\n      if (curChar === '>') {\n        endTag = '<';\n      } else {\n        endTag = '&';\n      }\n      while (curString.substr(curStrPos - 1).charAt(0) !== endTag) {\n        curStrPos--;\n        if (curStrPos < 0) {\n          break;\n        }\n      }\n      curStrPos--;\n    }\n    return curStrPos;\n  }\n}\n\nexport let htmlParser = new HTMLParser();\n"]}