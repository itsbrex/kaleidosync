{"version":3,"file":"MP4Parser-DTGyVtTK.js","sources":["../../../vue/node_modules/music-metadata/lib/mp4/AtomToken.js","../../../vue/node_modules/music-metadata/lib/mp4/Atom.js","../../../vue/node_modules/music-metadata/lib/mp4/MP4Parser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport initDebug from 'debug';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport * as util from '../common/Util.js';\nconst debug = initDebug('music-metadata:parser:MP4:atom');\nexport class Mp4ContentError extends makeUnexpectedFileContentError('MP4') {\n}\nexport const Header = {\n    len: 8,\n    get: (buf, off) => {\n        const length = Token.UINT32_BE.get(buf, off);\n        if (length < 0)\n            throw new Mp4ContentError('Invalid atom header length');\n        return {\n            length: BigInt(length),\n            name: new Token.StringType(4, 'latin1').get(buf, off + 4)\n        };\n    },\n    put: (buf, off, hdr) => {\n        Token.UINT32_BE.put(buf, off, Number(hdr.length));\n        return FourCcToken.put(buf, off + 4, hdr.name);\n    }\n};\n/**\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap1/qtff1.html#//apple_ref/doc/uid/TP40000939-CH203-38190\n */\nexport const ExtendedSize = Token.UINT64_BE;\nexport const ftyp = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            type: new Token.StringType(4, 'ascii').get(buf, off)\n        };\n    }\n};\n/**\n * Token: Movie Header Atom\n */\nexport const mhdr = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            nextItemID: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Base class for 'fixed' length atoms.\n * In some cases these atoms are longer then the sum of the described fields.\n * Issue: https://github.com/Borewit/music-metadata/issues/120\n */\nexport class FixedLengthAtom {\n    /**\n     *\n     * @param {number} len Length as specified in the size field\n     * @param {number} expLen Total length of sum of specified fields in the standard\n     * @param atomId Atom ID\n     */\n    constructor(len, expLen, atomId) {\n        if (len < expLen) {\n            throw new Mp4ContentError(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);\n        }\n        if (len > expLen) {\n            debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);\n        }\n        this.len = len;\n    }\n}\n/**\n * Timestamp stored in seconds since Mac Epoch (1 January 1904)\n */\nconst SecondsSinceMacEpoch = {\n    len: 4,\n    get: (buf, off) => {\n        const secondsSinceUnixEpoch = Token.UINT32_BE.get(buf, off) - 2082844800;\n        return new Date(secondsSinceUnixEpoch * 1000);\n    }\n};\n/**\n * Token: Media Header Atom\n * Ref:\n * - https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW34\n * - https://wiki.multimedia.cx/index.php/QuickTime_container#mdhd\n */\nexport class MdhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 24, 'mdhd');\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off + 0),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            language: Token.UINT16_BE.get(buf, off + 20),\n            quality: Token.UINT16_BE.get(buf, off + 22)\n        };\n    }\n}\n/**\n * Token: Movie Header Atom\n */\nexport class MvhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 100, 'mvhd');\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            preferredRate: Token.UINT32_BE.get(buf, off + 20),\n            preferredVolume: Token.UINT16_BE.get(buf, off + 24),\n            // ignore reserver: 10 bytes\n            // ignore matrix structure: 36 bytes\n            previewTime: Token.UINT32_BE.get(buf, off + 72),\n            previewDuration: Token.UINT32_BE.get(buf, off + 76),\n            posterTime: Token.UINT32_BE.get(buf, off + 80),\n            selectionTime: Token.UINT32_BE.get(buf, off + 84),\n            selectionDuration: Token.UINT32_BE.get(buf, off + 88),\n            currentTime: Token.UINT32_BE.get(buf, off + 92),\n            nextTrackID: Token.UINT32_BE.get(buf, off + 96)\n        };\n    }\n}\n/**\n * Data Atom Structure\n */\nexport class DataAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            type: {\n                set: Token.UINT8.get(buf, off + 0),\n                type: Token.UINT24_BE.get(buf, off + 1)\n            },\n            locale: Token.UINT24_BE.get(buf, off + 4),\n            value: new Token.Uint8ArrayType(this.len - 8).get(buf, off + 8)\n        };\n    }\n}\n/**\n * Data Atom Structure\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31\n */\nexport class NameAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            name: new Token.StringType(this.len - 4, 'utf-8').get(buf, off + 4)\n        };\n    }\n}\n/**\n * Track Header Atoms structure (`tkhd`)\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25550\n */\nexport class TrackHeaderAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            trackId: Token.UINT32_BE.get(buf, off + 12),\n            // reserved 4 bytes\n            duration: Token.UINT32_BE.get(buf, off + 20),\n            layer: Token.UINT16_BE.get(buf, off + 24),\n            alternateGroup: Token.UINT16_BE.get(buf, off + 26),\n            volume: Token.UINT16_BE.get(buf, off + 28) // ToDo: fixed point\n            // ToDo: add remaining fields\n        };\n    }\n}\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nconst stsdHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            numberOfEntries: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/documentation/quicktime-file-format/sample_description_atom\n */\nclass SampleDescriptionTable {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const descrLen = this.len - 12;\n        return {\n            dataFormat: FourCcToken.get(buf, off),\n            dataReferenceIndex: Token.UINT16_BE.get(buf, off + 10),\n            description: descrLen > 0 ? new Token.Uint8ArrayType(descrLen).get(buf, off + 12) : undefined\n        };\n    }\n}\n/**\n * Atom: Sample-description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nexport class StsdAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const header = stsdHeader.get(buf, off);\n        off += stsdHeader.len;\n        const table = [];\n        for (let n = 0; n < header.numberOfEntries; ++n) {\n            const size = Token.UINT32_BE.get(buf, off); // Sample description size\n            off += Token.UINT32_BE.len;\n            table.push(new SampleDescriptionTable(size - Token.UINT32_BE.len).get(buf, off));\n            off += size;\n        }\n        return {\n            header,\n            table\n        };\n    }\n}\n/**\n * Common Sound Sample Description (version & revision)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-57317\n */\nexport const SoundSampleDescriptionVersion = {\n    len: 8,\n    get(buf, off) {\n        return {\n            version: Token.INT16_BE.get(buf, off),\n            revision: Token.INT16_BE.get(buf, off + 2),\n            vendor: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Sound Sample Description (Version 0)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-130736\n */\nexport const SoundSampleDescriptionV0 = {\n    len: 12,\n    get(buf, off) {\n        return {\n            numAudioChannels: Token.INT16_BE.get(buf, off + 0),\n            sampleSize: Token.INT16_BE.get(buf, off + 2),\n            compressionId: Token.INT16_BE.get(buf, off + 4),\n            packetSize: Token.INT16_BE.get(buf, off + 6),\n            sampleRate: Token.UINT16_BE.get(buf, off + 8) + Token.UINT16_BE.get(buf, off + 10) / 10000\n        };\n    }\n};\nclass SimpleTableAtom {\n    constructor(len, token) {\n        this.len = len;\n        this.token = token;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 4);\n        return {\n            version: Token.INT8.get(buf, off + 0),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)\n        };\n    }\n}\nexport const TimeToSampleToken = {\n    len: 8,\n    get(buf, off) {\n        return {\n            count: Token.INT32_BE.get(buf, off + 0),\n            duration: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Time-to-sample('stts') atom.\n * Store duration information for a media’s samples.\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25696\n */\nexport class SttsAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, TimeToSampleToken);\n    }\n}\nexport const SampleToChunkToken = {\n    len: 12,\n    get(buf, off) {\n        return {\n            firstChunk: Token.INT32_BE.get(buf, off),\n            samplesPerChunk: Token.INT32_BE.get(buf, off + 4),\n            sampleDescriptionId: Token.INT32_BE.get(buf, off + 8)\n        };\n    }\n};\n/**\n * Sample-to-Chunk ('stsc') atom interface\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706\n */\nexport class StscAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, SampleToChunkToken);\n    }\n}\n/**\n * Sample-size ('stsz') atom\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25710\n */\nexport class StszAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 8);\n        return {\n            version: Token.INT8.get(buf, off),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            sampleSize: Token.INT32_BE.get(buf, off + 4),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, Token.INT32_BE, off + 12, this.len - 12, nrOfEntries)\n        };\n    }\n}\n/**\n * Chunk offset atom, 'stco'\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25715\n */\nexport class StcoAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, Token.INT32_BE);\n        this.len = len;\n    }\n}\n/**\n * Token used to decode text-track from 'mdat' atom (raw data stream)\n */\nexport class ChapterText {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const titleLen = Token.INT16_BE.get(buf, off + 0);\n        const str = new Token.StringType(titleLen, 'utf-8');\n        return str.get(buf, off + 2);\n    }\n}\nfunction readTokenTable(buf, token, off, remainingLen, numberOfEntries) {\n    debug(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);\n    if (remainingLen === 0)\n        return [];\n    if (remainingLen !== numberOfEntries * token.len)\n        throw new Mp4ContentError('mismatch number-of-entries with remaining atom-length');\n    const entries = [];\n    // parse offset-table\n    for (let n = 0; n < numberOfEntries; ++n) {\n        entries.push(token.get(buf, off));\n        off += token.len;\n    }\n    return entries;\n}\n/**\n * Sample-size ('tfhd') TrackFragmentHeaderBox\n */\nexport class TrackFragmentHeaderBox {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const flagOffset = off + 1;\n        const header = {\n            version: Token.INT8.get(buf, off),\n            flags: {\n                baseDataOffsetPresent: util.getBit(buf, flagOffset + 2, 0),\n                sampleDescriptionIndexPresent: util.getBit(buf, flagOffset + 2, 1),\n                defaultSampleDurationPresent: util.getBit(buf, flagOffset + 2, 3),\n                defaultSampleSizePresent: util.getBit(buf, flagOffset + 2, 4),\n                defaultSampleFlagsPresent: util.getBit(buf, flagOffset + 2, 5),\n                defaultDurationIsEmpty: util.getBit(buf, flagOffset, 0),\n                defaultBaseIsMoof: util.getBit(buf, flagOffset, 1)\n            },\n            trackId: Token.UINT32_BE.get(buf, 4)\n        };\n        let dynOffset = 8;\n        if (header.flags.baseDataOffsetPresent) {\n            header.baseDataOffset = Token.UINT64_BE.get(buf, dynOffset);\n            dynOffset += 8;\n        }\n        if (header.flags.sampleDescriptionIndexPresent) {\n            header.sampleDescriptionIndex = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        if (header.flags.defaultSampleDurationPresent) {\n            header.defaultSampleDuration = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        if (header.flags.defaultSampleSizePresent) {\n            header.defaultSampleSize = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        if (header.flags.defaultSampleFlagsPresent) {\n            header.defaultSampleFlags = Token.UINT32_BE.get(buf, dynOffset);\n        }\n        return header;\n    }\n}\n/**\n * Sample-size ('trun') TrackRunBox\n */\nexport class TrackRunBox {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const flagOffset = off + 1;\n        const trun = {\n            version: Token.INT8.get(buf, off),\n            flags: {\n                dataOffsetPresent: util.getBit(buf, flagOffset + 2, 0),\n                firstSampleFlagsPresent: util.getBit(buf, flagOffset + 2, 2),\n                sampleDurationPresent: util.getBit(buf, flagOffset + 1, 0),\n                sampleSizePresent: util.getBit(buf, flagOffset + 1, 1),\n                sampleFlagsPresent: util.getBit(buf, flagOffset + 1, 2),\n                sampleCompositionTimeOffsetsPresent: util.getBit(buf, flagOffset + 1, 3)\n            },\n            sampleCount: Token.UINT32_BE.get(buf, off + 4),\n            samples: []\n        };\n        let dynOffset = off + 8;\n        if (trun.flags.dataOffsetPresent) {\n            trun.dataOffset = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        if (trun.flags.firstSampleFlagsPresent) {\n            trun.firstSampleFlags = Token.UINT32_BE.get(buf, dynOffset);\n            dynOffset += 4;\n        }\n        for (let n = 0; n < trun.sampleCount; ++n) {\n            if (dynOffset >= this.len) {\n                debug(\"TrackRunBox size mismatch\");\n                break;\n            }\n            const sample = {};\n            if (trun.flags.sampleDurationPresent) {\n                sample.sampleDuration = Token.UINT32_BE.get(buf, dynOffset);\n                dynOffset += 4;\n            }\n            if (trun.flags.sampleSizePresent) {\n                sample.sampleSize = Token.UINT32_BE.get(buf, dynOffset);\n                dynOffset += 4;\n            }\n            if (trun.flags.sampleFlagsPresent) {\n                sample.sampleFlags = Token.UINT32_BE.get(buf, dynOffset);\n                dynOffset += 4;\n            }\n            if (trun.flags.sampleCompositionTimeOffsetsPresent) {\n                sample.sampleCompositionTimeOffset = Token.UINT32_BE.get(buf, dynOffset);\n                dynOffset += 4;\n            }\n            trun.samples.push(sample);\n        }\n        return trun;\n    }\n}\n/**\n * HandlerBox (`hdlr`)\n */\nexport class HandlerBox {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const _flagOffset = off + 1;\n        const charTypeToken = new Token.StringType(4, 'utf-8');\n        return {\n            version: Token.INT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            componentType: charTypeToken.get(buf, off + 4),\n            handlerType: charTypeToken.get(buf, off + 8),\n            componentName: new Token.StringType(this.len - 28, 'utf-8').get(buf, off + 28),\n        };\n    }\n}\n/**\n * Chapter Track Reference Box (`chap`)\n */\nexport class ChapterTrackReferenceBox {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        let dynOffset = 0;\n        const trackIds = [];\n        while (dynOffset < this.len) {\n            trackIds.push(Token.UINT32_BE.get(buf, off + dynOffset));\n            dynOffset += 4;\n        }\n        return trackIds;\n    }\n}\n//# sourceMappingURL=AtomToken.js.map","import initDebug from 'debug';\nimport * as AtomToken from './AtomToken.js';\nimport { Header } from './AtomToken.js';\nconst debug = initDebug('music-metadata:parser:MP4:Atom');\nexport class Atom {\n    static async readAtom(tokenizer, dataHandler, parent, remaining) {\n        // Parse atom header\n        const offset = tokenizer.position;\n        debug(`Reading next token on offset=${offset}...`); //  buf.toString('ascii')\n        const header = await tokenizer.readToken(AtomToken.Header);\n        const extended = header.length === 1n;\n        if (extended) {\n            header.length = await tokenizer.readToken(AtomToken.ExtendedSize);\n        }\n        const atomBean = new Atom(header, extended, parent);\n        const payloadLength = atomBean.getPayloadLength(remaining);\n        debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`); //  buf.toString('ascii')\n        await atomBean.readData(tokenizer, dataHandler, payloadLength);\n        return atomBean;\n    }\n    constructor(header, extended, parent) {\n        this.header = header;\n        this.extended = extended;\n        this.parent = parent;\n        this.children = [];\n        this.atomPath = (this.parent ? `${this.parent.atomPath}.` : '') + this.header.name;\n    }\n    getHeaderLength() {\n        return this.extended ? 16 : 8;\n    }\n    getPayloadLength(remaining) {\n        return (this.header.length === 0n ? remaining : Number(this.header.length)) - this.getHeaderLength();\n    }\n    async readAtoms(tokenizer, dataHandler, size) {\n        while (size > 0) {\n            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);\n            this.children.push(atomBean);\n            size -= atomBean.header.length === 0n ? size : Number(atomBean.header.length);\n        }\n    }\n    async readData(tokenizer, dataHandler, remaining) {\n        switch (this.header.name) {\n            // \"Container\" atoms, contains nested atoms\n            case 'moov': // The Movie Atom: contains other atoms\n            case 'udta': // User defined atom\n            case 'mdia': // Media atom\n            case 'minf': // Media Information Atom\n            case 'stbl': // The Sample Table Atom\n            case '<id>':\n            case 'ilst':\n            case 'tref':\n            case 'moof':\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));\n            case 'meta': { // Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n                // meta has 4 bytes of padding, ignore\n                const peekHeader = await tokenizer.peekToken(Header);\n                const paddingLength = peekHeader.name === 'hdlr' ? 0 : 4;\n                await tokenizer.ignore(paddingLength);\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);\n            }\n            default:\n                return dataHandler(this, remaining);\n        }\n    }\n}\n//# sourceMappingURL=Atom.js.map","import initDebug from 'debug';\nimport * as Token from 'token-types';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { Genres } from '../id3v1/ID3v1Parser.js';\nimport { Atom } from './Atom.js';\nimport * as AtomToken from './AtomToken.js';\nimport { ChapterTrackReferenceBox, Mp4ContentError, } from './AtomToken.js';\nimport { TrackType } from '../type.js';\nimport { uint8ArrayToHex, uint8ArrayToString } from 'uint8array-extras';\nconst debug = initDebug('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n    raw: {\n        lossy: false,\n        format: 'raw'\n    },\n    MAC3: {\n        lossy: true,\n        format: 'MACE 3:1'\n    },\n    MAC6: {\n        lossy: true,\n        format: 'MACE 6:1'\n    },\n    ima4: {\n        lossy: true,\n        format: 'IMA 4:1'\n    },\n    ulaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    alaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    Qclp: {\n        lossy: true,\n        format: 'QUALCOMM PureVoice'\n    },\n    '.mp3': {\n        lossy: true,\n        format: 'MPEG-1 layer 3'\n    },\n    alac: {\n        lossy: false,\n        format: 'ALAC'\n    },\n    'ac-3': {\n        lossy: true,\n        format: 'AC-3'\n    },\n    mp4a: {\n        lossy: true,\n        format: 'MPEG-4/AAC'\n    },\n    mp4s: {\n        lossy: true,\n        format: 'MP4S'\n    },\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n    c608: {\n        lossy: true,\n        format: 'CEA-608'\n    },\n    c708: {\n        lossy: true,\n        format: 'CEA-708'\n    }\n};\nfunction distinct(value, index, self) {\n    return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nexport class MP4Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.tracks = new Map();\n        this.hasVideoTrack = false;\n        this.hasAudioTrack = true;\n        this.atomParsers = {\n            /**\n             * Parse movie header (mvhd) atom\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n             */\n            mvhd: async (len) => {\n                const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n                this.metadata.setFormat('creationTime', mvhd.creationTime);\n                this.metadata.setFormat('modificationTime', mvhd.modificationTime);\n            },\n            chap: async (len) => {\n                const td = this.getTrackDescription();\n                const trackIds = [];\n                while (len >= Token.UINT32_BE.len) {\n                    trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n                    len -= Token.UINT32_BE.len;\n                }\n                td.chapterList = trackIds;\n            },\n            /**\n             * Parse mdat atom.\n             * Will scan for chapters\n             */\n            mdat: async (len) => {\n                this.audioLengthInBytes = len;\n                this.calculateBitRate();\n                if (this.options.includeChapters) {\n                    const trackWithChapters = [...this.tracks.values()].filter(track => track.chapterList);\n                    if (trackWithChapters.length === 1) {\n                        const chapterTrackIds = trackWithChapters[0].chapterList;\n                        const chapterTracks = [...this.tracks.values()].filter(track => chapterTrackIds.indexOf(track.header.trackId) !== -1);\n                        if (chapterTracks.length === 1) {\n                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n                        }\n                    }\n                }\n                await this.tokenizer.ignore(len);\n            },\n            ftyp: async (len) => {\n                const types = [];\n                while (len > 0) {\n                    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n                    len -= AtomToken.ftyp.len;\n                    const value = ftype.type.replace(/\\W/g, '');\n                    if (value.length > 0) {\n                        types.push(value); // unshift for backward compatibility\n                    }\n                }\n                debug(`ftyp: ${types.join('/')}`);\n                const x = types.filter(distinct).join('/');\n                this.metadata.setFormat('container', x);\n            },\n            /**\n             * Parse sample description atom\n             */\n            stsd: async (len) => {\n                const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n                const trackDescription = this.getTrackDescription();\n                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n            },\n            /**\n             * Parse sample-sizes atom ('stsz')\n             */\n            stsz: async (len) => {\n                const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n                const td = this.getTrackDescription();\n                td.sampleSize = stsz.sampleSize;\n                td.sampleSizeTable = stsz.entries;\n            },\n            date: async (len) => {\n                const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n                await this.addTag('date', date);\n            }\n        };\n    }\n    static read_BE_Integer(array, signed) {\n        const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\n        const token = Token[integerType];\n        if (!token) {\n            throw new Mp4ContentError(`Token for integer type not found: \"${integerType}\"`);\n        }\n        return Number(token.get(array, 0));\n    }\n    async parse() {\n        this.hasVideoTrack = false;\n        this.hasAudioTrack = true;\n        this.tracks.clear();\n        let remainingFileSize = this.tokenizer.fileInfo.size || 0;\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n            try {\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\n                if (token.name === '\\0\\0\\0\\0') {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                    break;\n                }\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                }\n                else\n                    throw error;\n                break;\n            }\n            const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\n        }\n        // Post process metadata\n        const formatList = [];\n        this.tracks.forEach(track => {\n            const trackFormats = [];\n            track.soundSampleDescription.forEach(ssd => {\n                const streamInfo = {};\n                const encoderInfo = encoderDict[ssd.dataFormat];\n                if (encoderInfo) {\n                    trackFormats.push(encoderInfo.format);\n                    streamInfo.codecName = encoderInfo.format;\n                }\n                else {\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\n                }\n                if (ssd.description) {\n                    const { description } = ssd;\n                    if (description.sampleRate > 0) {\n                        streamInfo.type = TrackType.audio;\n                        streamInfo.audio = {\n                            samplingFrequency: description.sampleRate,\n                            bitDepth: description.sampleSize,\n                            channels: description.numAudioChannels\n                        };\n                    }\n                }\n                this.metadata.addStreamInfo(streamInfo);\n            });\n            if (trackFormats.length >= 1) {\n                formatList.push(trackFormats.join('/'));\n            }\n        });\n        if (formatList.length > 0) {\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n        }\n        const audioTracks = [...this.tracks.values()].filter(track => {\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n        });\n        if (audioTracks.length >= 1) {\n            const audioTrack = audioTracks[0];\n            if (audioTrack.media.header && audioTrack.media.header.timeScale > 0) {\n                if (audioTrack.media.header.duration > 0) {\n                    debug('Using duration defined on audio track');\n                    const duration = audioTrack.media.header.duration / audioTrack.media.header.timeScale; // calculate duration in seconds\n                    this.metadata.setFormat('duration', duration);\n                }\n                else if (audioTrack.fragments.length > 0) {\n                    debug('Calculate duration defined in track fragments');\n                    let totalTimeUnits = 0;\n                    for (const fragment of audioTrack.fragments) {\n                        const defaultDuration = fragment.header.defaultSampleDuration;\n                        for (const sample of fragment.trackRun.samples) {\n                            const dur = sample.sampleDuration ?? defaultDuration;\n                            if (dur == null) {\n                                throw new Error(\"Missing sampleDuration and no default_sample_duration in tfhd\");\n                            }\n                            totalTimeUnits += dur;\n                        }\n                    }\n                    this.metadata.setFormat('duration', totalTimeUnits / audioTrack.media.header.timeScale);\n                }\n            }\n            const ssd = audioTrack.soundSampleDescription[0];\n            if (ssd.description && audioTrack.media.header) {\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n                if (audioTrack.media.header.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\n                    const totalSampleSize = audioTrack.timeToSampleTable\n                        .map(ttstEntry => ttstEntry.count * ttstEntry.duration)\n                        .reduce((total, sampleSize) => total + sampleSize);\n                    const duration = totalSampleSize / ssd.description.sampleRate;\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            const encoderInfo = encoderDict[ssd.dataFormat];\n            if (encoderInfo) {\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\n            }\n            this.calculateBitRate();\n        }\n        this.metadata.setFormat('hasAudio', this.hasAudioTrack);\n        this.metadata.setFormat('hasVideo', this.hasVideoTrack);\n    }\n    async handleAtom(atom, remaining) {\n        if (atom.parent) {\n            switch (atom.parent.header.name) {\n                case 'ilst':\n                case '<id>':\n                    return this.parseMetadataItemData(atom);\n                case 'moov':\n                    switch (atom.header.name) {\n                        case 'trak':\n                            return this.parseTrackBox(atom);\n                    }\n                    break;\n                case 'moof':\n                    switch (atom.header.name) {\n                        case 'traf':\n                            return this.parseTrackFragmentBox(atom);\n                    }\n            }\n        }\n        // const payloadLength = atom.getPayloadLength(remaining);\n        if (this.atomParsers[atom.header.name]) {\n            return this.atomParsers[atom.header.name](remaining);\n        }\n        debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\n        await this.tokenizer.ignore(remaining);\n    }\n    getTrackDescription() {\n        // ToDo: pick the right track, not the last track!!!!\n        const tracks = [...this.tracks.values()];\n        return tracks[tracks.length - 1];\n    }\n    calculateBitRate() {\n        if (this.audioLengthInBytes && this.metadata.format.duration) {\n            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n        }\n    }\n    async addTag(id, value) {\n        await this.metadata.addTag(tagFormat, id, value);\n    }\n    addWarning(message) {\n        debug(`Warning: ${message}`);\n        this.metadata.addWarning(message);\n    }\n    /**\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n     * @param metaAtom\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n     */\n    parseMetadataItemData(metaAtom) {\n        let tagKey = metaAtom.header.name;\n        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'data': // value atom\n                    return this.parseValueAtom(tagKey, child);\n                case 'name': // name atom (optional)\n                case 'mean':\n                case 'rate': {\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n                    tagKey += `:${name.name}`;\n                    break;\n                }\n                default: {\n                    const uint8Array = await this.tokenizer.readToken(new Token.Uint8ArrayType(payLoadLength));\n                    this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${uint8ArrayToString(uint8Array, 'ascii')}`);\n                }\n            }\n        }, metaAtom.getPayloadLength(0));\n    }\n    async parseValueAtom(tagKey, metaAtom) {\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\n        if (dataAtom.type.set !== 0) {\n            throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);\n        }\n        // Use well-known-type table\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n        switch (dataAtom.type.type) {\n            case 0: // reserved: Reserved for use where no type needs to be indicated\n                switch (tagKey) {\n                    case 'trkn':\n                    case 'disk': {\n                        const num = Token.UINT8.get(dataAtom.value, 3);\n                        const of = Token.UINT8.get(dataAtom.value, 5);\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n                        await this.addTag(tagKey, `${num}/${of}`);\n                        break;\n                    }\n                    case 'gnre': {\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\n                        const genreStr = Genres[genreInt - 1];\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n                        await this.addTag(tagKey, genreStr);\n                        break;\n                    }\n                    case 'rate': {\n                        const rate = new TextDecoder('ascii').decode(dataAtom.value);\n                        await this.addTag(tagKey, rate);\n                        break;\n                    }\n                    default:\n                        debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);\n                }\n                break;\n            case 1: // UTF-8: Without any count or NULL terminator\n            case 18: // Unknown: Found in m4b in combination with a '©gen' tag\n                await this.addTag(tagKey, new TextDecoder('utf-8').decode(dataAtom.value));\n                break;\n            case 13: // JPEG\n                if (this.options.skipCovers)\n                    break;\n                await this.addTag(tagKey, {\n                    format: 'image/jpeg',\n                    data: Uint8Array.from(dataAtom.value)\n                });\n                break;\n            case 14: // PNG\n                if (this.options.skipCovers)\n                    break;\n                await this.addTag(tagKey, {\n                    format: 'image/png',\n                    data: Uint8Array.from(dataAtom.value)\n                });\n                break;\n            case 21: // BE Signed Integer\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\n                break;\n            case 22: // BE Unsigned Integer\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\n                break;\n            case 65: // An 8-bit signed integer\n                await this.addTag(tagKey, Token.UINT8.get(dataAtom.value, 0));\n                break;\n            case 66: // A big-endian 16-bit signed integer\n                await this.addTag(tagKey, Token.UINT16_BE.get(dataAtom.value, 0));\n                break;\n            case 67: // A big-endian 32-bit signed integer\n                await this.addTag(tagKey, Token.UINT32_BE.get(dataAtom.value, 0));\n                break;\n            default:\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n        }\n    }\n    async parseTrackBox(trakBox) {\n        // @ts-ignore\n        const track = {\n            media: {},\n            fragments: []\n        };\n        await trakBox.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'chap': {\n                    const chap = await this.tokenizer.readToken(new ChapterTrackReferenceBox(remaining));\n                    track.chapterList = chap;\n                    break;\n                }\n                case 'tkhd': // TrackHeaderBox\n                    track.header = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(payLoadLength));\n                    break;\n                case 'hdlr': // TrackHeaderBox\n                    track.handler = await this.tokenizer.readToken(new AtomToken.HandlerBox(payLoadLength));\n                    switch (track.handler.handlerType) {\n                        case 'audi':\n                            debug('Contains audio track');\n                            this.hasAudioTrack = true;\n                            break;\n                        case 'vide':\n                            debug('Contains video track');\n                            this.hasVideoTrack = true;\n                            break;\n                    }\n                    break;\n                case 'mdhd': { // Parse media header (mdhd) box\n                    const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(payLoadLength));\n                    track.media.header = mdhd_data;\n                    break;\n                }\n                case 'stco': {\n                    const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(payLoadLength));\n                    track.chunkOffsetTable = stco.entries; // remember chunk offsets\n                    break;\n                }\n                case 'stsc': { // sample-to-Chunk box\n                    const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(payLoadLength));\n                    track.sampleToChunkTable = stsc.entries;\n                    break;\n                }\n                case 'stsd': { // sample description box\n                    const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(payLoadLength));\n                    track.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n                    break;\n                }\n                case 'stts': { // time-to-sample table\n                    const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(payLoadLength));\n                    track.timeToSampleTable = stts.entries;\n                    break;\n                }\n                case 'stsz': {\n                    const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(payLoadLength));\n                    track.sampleSize = stsz.sampleSize;\n                    track.sampleSizeTable = stsz.entries;\n                    break;\n                }\n                case 'dinf':\n                case 'vmhd':\n                case 'smhd':\n                    debug(`Ignoring: ${child.header.name}`);\n                    await this.tokenizer.ignore(payLoadLength);\n                    break;\n                default: {\n                    debug(`Unexpected track box: ${child.header.name}`);\n                    await this.tokenizer.ignore(payLoadLength);\n                }\n            }\n        }, trakBox.getPayloadLength(0));\n        // Register track\n        this.tracks.set(track.header.trackId, track);\n    }\n    parseTrackFragmentBox(trafBox) {\n        let tfhd;\n        return trafBox.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'tfhd': { // TrackFragmentHeaderBox\n                    const fragmentHeaderBox = new AtomToken.TrackFragmentHeaderBox(child.getPayloadLength(remaining));\n                    tfhd = await this.tokenizer.readToken(fragmentHeaderBox);\n                    break;\n                }\n                case 'tfdt': // TrackFragmentBaseMediaDecodeTimeBo\n                    await this.tokenizer.ignore(payLoadLength);\n                    break;\n                case 'trun': { // TrackRunBox\n                    const trackRunBox = new AtomToken.TrackRunBox(payLoadLength);\n                    const trun = await this.tokenizer.readToken(trackRunBox);\n                    if (tfhd) {\n                        const track = this.tracks.get(tfhd.trackId);\n                        track?.fragments.push({ header: tfhd, trackRun: trun });\n                    }\n                    break;\n                }\n                default: {\n                    debug(`Unexpected box: ${child.header.name}`);\n                    await this.tokenizer.ignore(payLoadLength);\n                }\n            }\n        }, trafBox.getPayloadLength(0));\n    }\n    /**\n     * @param sampleDescription\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n     */\n    parseSoundSampleDescription(sampleDescription) {\n        const ssd = {\n            dataFormat: sampleDescription.dataFormat,\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\n        };\n        let offset = 0;\n        if (sampleDescription.description) {\n            const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n            offset += AtomToken.SoundSampleDescriptionVersion.len;\n            if (version.version === 0 || version.version === 1) {\n                // Sound Sample Description (Version 0)\n                ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n            }\n            else {\n                debug(`Warning: sound-sample-description ${version} not implemented`);\n            }\n        }\n        return ssd;\n    }\n    async parseChapterTrack(chapterTrack, track, len) {\n        if (!chapterTrack.sampleSize) {\n            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n        }\n        const chapters = [];\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n            const start = chapterTrack.timeToSampleTable\n                .slice(0, i)\n                .reduce((acc, cur) => acc + cur.duration, 0);\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n            len -= nextChunkLen + sampleSize;\n            if (len < 0)\n                throw new Mp4ContentError('Chapter chunk exceeding token length');\n            await this.tokenizer.ignore(nextChunkLen);\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n            debug(`Chapter ${i + 1}: ${title}`);\n            const chapter = {\n                title,\n                timeScale: chapterTrack.media.header ? chapterTrack.media.header.timeScale : 0,\n                start,\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n            };\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${track.header.duration}`); // ToDo, use media duration if required!!!\n            chapters.push(chapter);\n        }\n        this.metadata.setFormat('chapters', chapters);\n        await this.tokenizer.ignore(len);\n    }\n    findSampleOffset(track, chapterOffset) {\n        let chunkIndex = 0;\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n            ++chunkIndex;\n        }\n        return this.getChunkDuration(chunkIndex + 1, track);\n    }\n    getChunkDuration(chunkId, track) {\n        let ttsi = 0;\n        let ttsc = track.timeToSampleTable[ttsi].count;\n        let ttsd = track.timeToSampleTable[ttsi].duration;\n        let curChunkId = 1;\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n        let totalDuration = 0;\n        while (curChunkId < chunkId) {\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n            totalDuration += nrOfSamples * ttsd;\n            ttsc -= nrOfSamples;\n            samplesPerChunk -= nrOfSamples;\n            if (samplesPerChunk === 0) {\n                ++curChunkId;\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n            }\n            else {\n                ++ttsi;\n                ttsc = track.timeToSampleTable[ttsi].count;\n                ttsd = track.timeToSampleTable[ttsi].duration;\n            }\n        }\n        return totalDuration;\n    }\n    getSamplesPerChunk(chunkId, stcTable) {\n        for (let i = 0; i < stcTable.length - 1; ++i) {\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n                return stcTable[i].samplesPerChunk;\n            }\n        }\n        return stcTable[stcTable.length - 1].samplesPerChunk;\n    }\n}\n//# sourceMappingURL=MP4Parser.js.map"],"names":["debug","initDebug","Mp4ContentError","makeUnexpectedFileContentError","Header","buf","off","length","Token.UINT32_BE","Token.StringType","hdr","FourCcToken","ExtendedSize","Token.UINT64_BE","ftyp","FixedLengthAtom","len","expLen","atomId","SecondsSinceMacEpoch","secondsSinceUnixEpoch","MdhdAtom","Token.UINT8","Token.UINT24_BE","Token.UINT16_BE","MvhdAtom","DataAtom","Token.Uint8ArrayType","NameAtom","TrackHeaderAtom","stsdHeader","SampleDescriptionTable","descrLen","StsdAtom","header","table","size","SoundSampleDescriptionVersion","Token.INT16_BE","Token.INT32_BE","SoundSampleDescriptionV0","SimpleTableAtom","token","nrOfEntries","Token.INT8","Token.INT24_BE","readTokenTable","TimeToSampleToken","SttsAtom","SampleToChunkToken","StscAtom","StszAtom","StcoAtom","ChapterText","titleLen","remainingLen","numberOfEntries","entries","n","TrackFragmentHeaderBox","flagOffset","util.getBit","dynOffset","TrackRunBox","trun","sample","HandlerBox","charTypeToken","ChapterTrackReferenceBox","trackIds","Atom","tokenizer","dataHandler","parent","remaining","offset","AtomToken.Header","extended","AtomToken.ExtendedSize","atomBean","payloadLength","paddingLength","tagFormat","encoderDict","distinct","value","index","self","MP4Parser","BasicParser","mvhd","AtomToken.MvhdAtom","td","trackWithChapters","track","chapterTrackIds","chapterTracks","types","ftype","AtomToken.ftyp","x","stsd","AtomToken.StsdAtom","trackDescription","dfEntry","stsz","AtomToken.StszAtom","date","array","signed","integerType","Token","remainingFileSize","errMsg","error","rootAtom","atom","formatList","trackFormats","ssd","streamInfo","encoderInfo","description","TrackType","audioTracks","audioTrack","duration","totalTimeUnits","fragment","defaultDuration","dur","ttstEntry","total","sampleSize","tracks","id","message","metaAtom","tagKey","child","payLoadLength","name","AtomToken.NameAtom","uint8Array","uint8ArrayToHex","uint8ArrayToString","dataAtom","AtomToken.DataAtom","num","of","genreInt","genreStr","Genres","rate","trakBox","chap","AtomToken.TrackHeaderAtom","AtomToken.HandlerBox","mdhd_data","AtomToken.MdhdAtom","stco","AtomToken.StcoAtom","stsc","AtomToken.StscAtom","stts","AtomToken.SttsAtom","trafBox","tfhd","fragmentHeaderBox","AtomToken.TrackFragmentHeaderBox","trackRunBox","AtomToken.TrackRunBox","sampleDescription","version","AtomToken.SoundSampleDescriptionVersion","AtomToken.SoundSampleDescriptionV0","chapterTrack","chapters","i","start","acc","cur","nextChunkLen","title","AtomToken.ChapterText","chapter","chapterOffset","chunkIndex","chunkId","ttsi","ttsc","ttsd","curChunkId","samplesPerChunk","totalDuration","nrOfSamples","stcTable"],"mappings":"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","x_google_ignoreList":[0,1,2]}