{"version":3,"file":"DsfParser-DGmzLXHx.js","sources":["../../../vue/node_modules/music-metadata/lib/dsf/DsfChunk.js","../../../vue/node_modules/music-metadata/lib/dsf/DsfParser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport { FourCcToken } from '../common/FourCC.js';\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexport const ChunkHeader = {\n    len: 12,\n    get: (buf, off) => {\n        return { id: FourCcToken.get(buf, off), size: Token.UINT64_LE.get(buf, off + 4) };\n    }\n};\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexport const DsdChunk = {\n    len: 16,\n    get: (buf, off) => {\n        return {\n            fileSize: Token.INT64_LE.get(buf, off),\n            metadataPointer: Token.INT64_LE.get(buf, off + 8)\n        };\n    }\n};\nexport const ChannelType = {\n    mono: 1,\n    stereo: 2,\n    channels: 3,\n    quad: 4,\n    '4 channels': 5,\n    '5 channels': 6,\n    '5.1 channels': 7\n};\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexport const FormatChunk = {\n    len: 40,\n    get: (buf, off) => {\n        return {\n            formatVersion: Token.INT32_LE.get(buf, off),\n            formatID: Token.INT32_LE.get(buf, off + 4),\n            channelType: Token.INT32_LE.get(buf, off + 8),\n            channelNum: Token.INT32_LE.get(buf, off + 12),\n            samplingFrequency: Token.INT32_LE.get(buf, off + 16),\n            bitsPerSample: Token.INT32_LE.get(buf, off + 20),\n            sampleCount: Token.INT64_LE.get(buf, off + 24),\n            blockSizePerChannel: Token.INT32_LE.get(buf, off + 32)\n        };\n    }\n};\n//# sourceMappingURL=DsfChunk.js.map","import initDebug from 'debug';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { ChunkHeader, DsdChunk, FormatChunk } from './DsfChunk.js';\nimport { ID3v2Parser } from \"../id3v2/ID3v2Parser.js\";\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:DSF');\nexport class DsdContentParseError extends makeUnexpectedFileContentError('DSD') {\n}\n/**\n * DSF (dsd stream file) File Parser\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\n */\nexport class DsfParser extends AbstractID3Parser {\n    async postId3v2Parse() {\n        const p0 = this.tokenizer.position; // mark start position, normally 0\n        const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\n        if (chunkHeader.id !== 'DSD ')\n            throw new DsdContentParseError('Invalid chunk signature');\n        this.metadata.setFormat('container', 'DSF');\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setAudioOnly();\n        const dsdChunk = await this.tokenizer.readToken(DsdChunk);\n        if (dsdChunk.metadataPointer === BigInt(0)) {\n            debug(\"No ID3v2 tag present\");\n        }\n        else {\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n            // Jump to ID3 header\n            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\n            return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n        }\n    }\n    async parseChunks(bytesRemaining) {\n        while (bytesRemaining >= ChunkHeader.len) {\n            const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n            switch (chunkHeader.id) {\n                case 'fmt ': {\n                    const formatChunk = await this.tokenizer.readToken(FormatChunk);\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n                    this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n                    this.metadata.setFormat('bitrate', bitrate);\n                    return; // We got what we want, stop further processing of chunks\n                }\n                default:\n                    this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);\n                    break;\n            }\n            bytesRemaining -= chunkHeader.size;\n        }\n    }\n}\n//# sourceMappingURL=DsfParser.js.map"],"names":["ChunkHeader","buf","off","FourCcToken","Token.UINT64_LE","DsdChunk","Token.INT64_LE","FormatChunk","Token.INT32_LE","debug","initDebug","DsdContentParseError","makeUnexpectedFileContentError","DsfParser","AbstractID3Parser","p0","chunkHeader","dsdChunk","ID3v2Parser","bytesRemaining","formatChunk","bitrate"],"mappings":"oNAKO,MAAMA,EAAc,CACvB,IAAK,GACL,IAAK,CAACC,EAAKC,KACA,CAAE,GAAIC,EAAY,IAAIF,EAAKC,CAAG,EAAG,KAAME,EAAgB,IAAIH,EAAKC,EAAM,CAAC,CAAC,EAEvF,EAIaG,EAAW,CACpB,IAAK,GACL,IAAK,CAACJ,EAAKC,KACA,CACH,SAAUI,EAAe,IAAIL,EAAKC,CAAG,EACrC,gBAAiBI,EAAe,IAAIL,EAAKC,EAAM,CAAC,CAC5D,EAEA,EAaaK,EAAc,CACvB,IAAK,GACL,IAAK,CAACN,EAAKC,KACA,CACH,cAAeM,EAAe,IAAIP,EAAKC,CAAG,EAC1C,SAAUM,EAAe,IAAIP,EAAKC,EAAM,CAAC,EACzC,YAAaM,EAAe,IAAIP,EAAKC,EAAM,CAAC,EAC5C,WAAYM,EAAe,IAAIP,EAAKC,EAAM,EAAE,EAC5C,kBAAmBM,EAAe,IAAIP,EAAKC,EAAM,EAAE,EACnD,cAAeM,EAAe,IAAIP,EAAKC,EAAM,EAAE,EAC/C,YAAaI,EAAe,IAAIL,EAAKC,EAAM,EAAE,EAC7C,oBAAqBM,EAAe,IAAIP,EAAKC,EAAM,EAAE,CACjE,EAEA,EC5CMO,EAAQC,EAAU,2BAA2B,EAC5C,MAAMC,UAA6BC,EAA+B,KAAK,CAAE,CAChF,CAKO,MAAMC,UAAkBC,CAAkB,CAC7C,MAAM,gBAAiB,CACnB,MAAMC,EAAK,KAAK,UAAU,SACpBC,EAAc,MAAM,KAAK,UAAU,UAAUhB,CAAW,EAC9D,GAAIgB,EAAY,KAAO,OACnB,MAAM,IAAIL,EAAqB,yBAAyB,EAC5D,KAAK,SAAS,UAAU,YAAa,KAAK,EAC1C,KAAK,SAAS,UAAU,WAAY,EAAI,EACxC,KAAK,SAAS,aAAY,EAC1B,MAAMM,EAAW,MAAM,KAAK,UAAU,UAAUZ,CAAQ,EACxD,GAAIY,EAAS,kBAAoB,OAAO,CAAC,EACrCR,EAAM,sBAAsB,MAG5B,QAAAA,EAAM,0BAA0BQ,EAAS,eAAe,EAAE,EAC1D,MAAM,KAAK,YAAYA,EAAS,SAAWD,EAAY,IAAI,EAE3D,MAAM,KAAK,UAAU,OAAO,OAAOC,EAAS,eAAe,EAAI,KAAK,UAAU,SAAWF,CAAE,EACpF,IAAIG,IAAc,MAAM,KAAK,SAAU,KAAK,UAAW,KAAK,OAAO,CAElF,CACA,MAAM,YAAYC,EAAgB,CAC9B,KAAOA,GAAkBnB,EAAY,KAAK,CACtC,MAAMgB,EAAc,MAAM,KAAK,UAAU,UAAUhB,CAAW,EAE9D,OADAS,EAAM,sBAAsBO,EAAY,EAAE,SAASA,EAAY,IAAI,EAAE,EAC7DA,EAAY,GAAE,CAClB,IAAK,OAAQ,CACT,MAAMI,EAAc,MAAM,KAAK,UAAU,UAAUb,CAAW,EAC9D,KAAK,SAAS,UAAU,mBAAoBa,EAAY,UAAU,EAClE,KAAK,SAAS,UAAU,aAAcA,EAAY,iBAAiB,EACnE,KAAK,SAAS,UAAU,gBAAiBA,EAAY,aAAa,EAClE,KAAK,SAAS,UAAU,kBAAmBA,EAAY,WAAW,EAClE,KAAK,SAAS,UAAU,WAAY,OAAOA,EAAY,WAAW,EAAIA,EAAY,iBAAiB,EACnG,MAAMC,EAAUD,EAAY,cAAgBA,EAAY,kBAAoBA,EAAY,WACxF,KAAK,SAAS,UAAU,UAAWC,CAAO,EAC1C,MACJ,CACA,QACI,KAAK,UAAU,OAAO,OAAOL,EAAY,IAAI,EAAIhB,EAAY,GAAG,EAChE,KACpB,CACYmB,GAAkBH,EAAY,IAClC,CACJ,CACJ","x_google_ignoreList":[0,1]}