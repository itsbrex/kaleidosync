{"version":3,"file":"VorbisStream-CvBVCMjB.js","sources":["../../node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js","../../node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js","../../node_modules/music-metadata/lib/ogg/vorbis/VorbisStream.js"],"sourcesContent":["import * as Token from 'token-types';\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nexport class VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexport const CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: Token.UINT8.get(buf, off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexport const IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n//# sourceMappingURL=Vorbis.js.map","import * as Token from 'token-types';\nexport class VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = new TextDecoder('utf-8').decode(this.data.subarray(this.offset, this.offset + len));\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.slice(0, idx).toUpperCase(),\n            value: v.slice(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n//# sourceMappingURL=VorbisDecoder.js.map","import * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggStream\n */\nexport class VorbisStream {\n    constructor(metadata, options) {\n        this.pageSegments = [];\n        this.metadata = metadata;\n        this.options = options;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        this.lastPageHeader = header;\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration() {\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param header\n     * @param pageData\n     */\n    parseFirstPage(_header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        this.metadata.setFormat('hasAudio', true);\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n//# sourceMappingURL=VorbisStream.js.map"],"names":["VorbisPictureToken","base64str","c","buffer","len","offset","type","AttachedPictureType","Token.UINT32_BE","mimeLen","format","Token.StringType","descLen","description","width","height","colour_depth","indexed_color","picDataLen","data","CommonHeader","buf","off","Token.UINT8","IdentificationHeader","uint8Array","Token.UINT32_LE","VorbisDecoder","value","offset0","v","idx","debug","debugInit","VorbisContentError","makeUnexpectedFileContentError","VorbisStream","metadata","options","header","pageData","fullPage","arrays","totalSize","acc","e","merged","array","i","_arrays","tag","id","_header","commonHeader","idHeader","strLen","userCommentListLength"],"mappings":"6FAQO,MAAMA,CAAmB,CAC5B,OAAO,WAAWC,EAAW,CACzB,OAAOD,EAAmB,WAAW,WAAW,KAAK,KAAKC,CAAS,EAAGC,GAAKA,EAAE,WAAW,CAAC,CAAC,CAAC,CACnG,CACI,OAAO,WAAWC,EAAQ,CAEtB,OADY,IAAIH,EAAmBG,EAAO,MAAM,EACrC,IAAIA,EAAQ,CAAC,CAChC,CACI,YAAYC,EAAK,CACb,KAAK,IAAMA,CACnB,CACI,IAAID,EAAQE,EAAQ,CAChB,MAAMC,EAAOC,EAAoBC,EAAgB,IAAIL,EAAQE,CAAM,CAAC,EACpEA,GAAU,EACV,MAAMI,EAAUD,EAAgB,IAAIL,EAAQE,CAAM,EAClDA,GAAU,EACV,MAAMK,EAAS,IAAIC,EAAiBF,EAAS,OAAO,EAAE,IAAIN,EAAQE,CAAM,EACxEA,GAAUI,EACV,MAAMG,EAAUJ,EAAgB,IAAIL,EAAQE,CAAM,EAClDA,GAAU,EACV,MAAMQ,EAAc,IAAIF,EAAiBC,EAAS,OAAO,EAAE,IAAIT,EAAQE,CAAM,EAC7EA,GAAUO,EACV,MAAME,EAAQN,EAAgB,IAAIL,EAAQE,CAAM,EAChDA,GAAU,EACV,MAAMU,EAASP,EAAgB,IAAIL,EAAQE,CAAM,EACjDA,GAAU,EACV,MAAMW,EAAeR,EAAgB,IAAIL,EAAQE,CAAM,EACvDA,GAAU,EACV,MAAMY,EAAgBT,EAAgB,IAAIL,EAAQE,CAAM,EACxDA,GAAU,EACV,MAAMa,EAAaV,EAAgB,IAAIL,EAAQE,CAAM,EACrDA,GAAU,EACV,MAAMc,EAAO,WAAW,KAAKhB,EAAO,MAAME,EAAQA,EAASa,CAAU,CAAC,EACtE,MAAO,CACH,KAAAZ,EACA,OAAAI,EACA,YAAAG,EACA,MAAAC,EACA,OAAAC,EACA,aAAAC,EACA,cAAAC,EACA,KAAAE,CACZ,CACA,CACA,CAKO,MAAMC,EAAe,CACxB,IAAK,EACL,IAAK,CAACC,EAAKC,KACA,CACH,WAAYC,EAAY,IAAIF,EAAKC,CAAG,EACpC,OAAQ,IAAIX,EAAiB,EAAG,OAAO,EAAE,IAAIU,EAAKC,EAAM,CAAC,CACrE,EAEA,EAKaE,EAAuB,CAChC,IAAK,GACL,IAAK,CAACC,EAAYH,KACP,CACH,QAASI,EAAgB,IAAID,EAAYH,EAAM,CAAC,EAChD,YAAaC,EAAY,IAAIE,EAAYH,EAAM,CAAC,EAChD,WAAYI,EAAgB,IAAID,EAAYH,EAAM,CAAC,EACnD,WAAYI,EAAgB,IAAID,EAAYH,EAAM,CAAC,EACnD,eAAgBI,EAAgB,IAAID,EAAYH,EAAM,EAAE,EACxD,WAAYI,EAAgB,IAAID,EAAYH,EAAM,EAAE,CAChE,EAEA,ECjFO,MAAMK,CAAc,CACvB,YAAYR,EAAMd,EAAQ,CACtB,KAAK,KAAOc,EACZ,KAAK,OAASd,CACtB,CACI,WAAY,CACR,MAAMuB,EAAQF,EAAgB,IAAI,KAAK,KAAM,KAAK,MAAM,EACxD,YAAK,QAAU,EACRE,CACf,CACI,gBAAiB,CACb,MAAMxB,EAAM,KAAK,UAAS,EACpBwB,EAAQ,IAAI,YAAY,OAAO,EAAE,OAAO,KAAK,KAAK,SAAS,KAAK,OAAQ,KAAK,OAASxB,CAAG,CAAC,EAChG,YAAK,QAAUA,EACRwB,CACf,CACI,kBAAmB,CACf,MAAMC,EAAU,KAAK,OACfC,EAAI,KAAK,eAAc,EACvBC,EAAMD,EAAE,QAAQ,GAAG,EACzB,MAAO,CACH,IAAKA,EAAE,MAAM,EAAGC,CAAG,EAAE,YAAW,EAChC,MAAOD,EAAE,MAAMC,EAAM,CAAC,EACtB,IAAK,KAAK,OAASF,CAC/B,CACA,CACA,CCtBA,MAAMG,EAAQC,EAAU,mCAAmC,EACpD,MAAMC,UAA2BC,EAA+B,QAAQ,CAAE,CACjF,CAKO,MAAMC,CAAa,CACtB,YAAYC,EAAUC,EAAS,CAC3B,KAAK,aAAe,CAAA,EACpB,KAAK,SAAWD,EAChB,KAAK,QAAUC,CACvB,CAMI,MAAM,UAAUC,EAAQC,EAAU,CAE9B,GADA,KAAK,eAAiBD,EAClBA,EAAO,WAAW,UAClB,KAAK,eAAeA,EAAQC,CAAQ,MAEnC,CACD,GAAID,EAAO,WAAW,UAAW,CAC7B,GAAI,KAAK,aAAa,SAAW,EAC7B,MAAM,IAAIL,EAAmB,kCAAkC,EAEnE,KAAK,aAAa,KAAKM,CAAQ,CAC/C,CACY,GAAID,EAAO,WAAW,UAAY,CAACA,EAAO,WAAW,UAAW,CAE5D,GAAI,KAAK,aAAa,OAAS,EAAG,CAC9B,MAAME,EAAWL,EAAa,iBAAiB,KAAK,YAAY,EAChE,MAAM,KAAK,cAAcK,CAAQ,CACrD,CAEgB,KAAK,aAAeF,EAAO,WAAW,SAAW,CAAA,EAAK,CAACC,CAAQ,CAC/E,CACA,CACA,CACI,OAAO,iBAAiBE,EAAQ,CAC5B,MAAMC,EAAYD,EAAO,OAAO,CAACE,EAAKC,IAAMD,EAAMC,EAAE,OAAQ,CAAC,EACvDC,EAAS,IAAI,WAAWH,CAAS,EACvC,OAAAD,EAAO,QAAQ,CAACK,EAAOC,EAAGC,IAAY,CAClC,MAAM5C,EAAS4C,EAAQ,MAAM,EAAGD,CAAC,EAAE,OAAO,CAACJ,EAAKC,IAAMD,EAAMC,EAAE,OAAQ,CAAC,EACvEC,EAAO,IAAIC,EAAO1C,CAAM,CACpC,CAAS,EACMyC,CACf,CACI,MAAM,OAAQ,CACV,MAAM,KAAK,cAAcV,EAAa,iBAAiB,KAAK,YAAY,CAAC,CACjF,CACI,MAAM,iBAAiBI,EAAUnC,EAAQ,CAErC,MAAM6C,EADU,IAAIvB,EAAca,EAAUnC,CAAM,EAC9B,iBAAgB,EACpC,aAAM,KAAK,OAAO6C,EAAI,IAAKA,EAAI,KAAK,EAC7BA,EAAI,GACnB,CACI,MAAM,OAAOC,EAAIvB,EAAO,CACpB,GAAIuB,IAAO,0BAA6B,OAAOvB,GAAU,SAAW,CAChE,GAAI,KAAK,QAAQ,WAAY,CACzBI,EAAM,gBAAgB,EACtB,MAChB,CACYJ,EAAQ5B,EAAmB,WAAW4B,CAAK,EAC3CI,EAAM,oBAAoBmB,CAAE,YAAYvB,EAAM,MAAM,EAAE,CAClE,MAEYI,EAAM,gBAAgBmB,CAAE,WAAWvB,CAAK,EAAE,EAE9C,MAAM,KAAK,SAAS,OAAO,SAAUuB,EAAIvB,CAAK,CACtD,CACI,mBAAoB,CACZ,KAAK,gBAAkB,KAAK,SAAS,OAAO,YAAc,KAAK,eAAe,yBAA2B,IAEzG,KAAK,SAAS,UAAU,kBAAmB,KAAK,eAAe,uBAAuB,EACtF,KAAK,SAAS,UAAU,WAAY,KAAK,eAAe,wBAA0B,KAAK,SAAS,OAAO,UAAU,EAE7H,CAMI,eAAewB,EAASZ,EAAU,CAC9B,KAAK,SAAS,UAAU,QAAS,UAAU,EAC3C,KAAK,SAAS,UAAU,WAAY,EAAI,EACxCR,EAAM,kBAAkB,EAExB,MAAMqB,EAAejC,EAAa,IAAIoB,EAAU,CAAC,EACjD,GAAIa,EAAa,SAAW,SACxB,MAAM,IAAInB,EAAmB,oCAAoC,EACrE,GAAImB,EAAa,aAAe,EAAG,CAC/B,MAAMC,EAAW9B,EAAqB,IAAIgB,EAAUpB,EAAa,GAAG,EACpE,KAAK,SAAS,UAAU,aAAckC,EAAS,UAAU,EACzD,KAAK,SAAS,UAAU,UAAWA,EAAS,cAAc,EAC1D,KAAK,SAAS,UAAU,mBAAoBA,EAAS,WAAW,EAChEtB,EAAM,uDAAwDsB,EAAS,WAAYA,EAAS,eAAgBA,EAAS,WAAW,CAC5I,KAEY,OAAM,IAAIpB,EAAmB,4DAA4D,CACrG,CACI,MAAM,cAAcM,EAAU,CAE1B,MAAMa,EAAejC,EAAa,IAAIoB,EAAU,CAAC,EAEjD,OADAR,EAAM,0CAA2CqB,EAAa,WAAYb,EAAS,UAAU,EACrFa,EAAa,WAAU,CAC3B,IAAK,GACD,OAAO,KAAK,qBAAqBb,EAAUpB,EAAa,GAAG,CAI3E,CACA,CAII,MAAM,qBAAqBoB,EAAUnC,EAAQ,CACzC,MAAMkD,EAAS7B,EAAgB,IAAIc,EAAUnC,CAAM,EACnDA,GAAU,EAEVA,GAAUkD,EACV,IAAIC,EAAwB9B,EAAgB,IAAIc,EAAUnC,CAAM,EAEhE,IADAA,GAAU,EACHmD,KAA0B,GAC7BnD,GAAW,MAAM,KAAK,iBAAiBmC,EAAUnC,CAAM,CAEnE,CACA","x_google_ignoreList":[0,1,2]}