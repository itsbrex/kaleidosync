{"version":3,"file":"MpegParser-Dw0N6tnJ.js","sources":["../../node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js","../../node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js","../../node_modules/music-metadata/lib/mpeg/XingTag.js","../../node_modules/music-metadata/lib/mpeg/MpegParser.js"],"sourcesContent":["import * as common from '../common/Util.js';\n/**\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#name-code\n */\nconst NameCode = {\n    /**\n     * not set\n     */\n    not_set: 0,\n    /**\n     * Radio Gain Adjustment\n     */\n    radio: 1,\n    /**\n     * Audiophile Gain Adjustment\n     */\n    audiophile: 2\n};\n/**\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#originator-code\n */\nconst ReplayGainOriginator = {\n    /**\n     * Replay Gain unspecified\n     */\n    unspecified: 0,\n    /**\n     * Replay Gain pre-set by artist/producer/mastering engineer\n     */\n    engineer: 1,\n    /**\n     * Replay Gain set by user\n     */\n    user: 2,\n    /**\n     * Replay Gain determined automatically, as described on this site\n     */\n    automatic: 3,\n    /**\n     * Set by simple RMS average\n     */\n    rms_average: 4\n};\n/**\n * Replay Gain Data Format\n *\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format\n */\nexport const ReplayGain = {\n    len: 2,\n    get: (buf, off) => {\n        const gain_type = common.getBitAllignedNumber(buf, off, 0, 3);\n        const sign = common.getBitAllignedNumber(buf, off, 6, 1);\n        const gain_adj = common.getBitAllignedNumber(buf, off, 7, 9) / 10.0;\n        if (gain_type > 0) {\n            return {\n                type: common.getBitAllignedNumber(buf, off, 0, 3),\n                origin: common.getBitAllignedNumber(buf, off, 3, 3),\n                adjustment: (sign ? -gain_adj : gain_adj)\n            };\n        }\n        return undefined;\n    }\n};\n//# sourceMappingURL=ReplayGainDataFormat.js.map","/**\n * Extended Lame Header\n */\nimport * as Token from 'token-types';\nimport * as common from '../common/Util.js';\nimport { ReplayGain } from './ReplayGainDataFormat.js';\n/**\n * Info Tag\n * @link http://gabriel.mp3-tech.org/mp3infotag.html\n * @link https://github.com/quodlibet/mutagen/blob/abd58ee58772224334a18817c3fb31103572f70e/mutagen/mp3/_util.py#L112\n */\nexport const ExtendedLameHeader = {\n    len: 27,\n    get: (buf, off) => {\n        const track_peak = Token.UINT32_BE.get(buf, off + 2);\n        return {\n            revision: common.getBitAllignedNumber(buf, off, 0, 4),\n            vbr_method: common.getBitAllignedNumber(buf, off, 4, 4),\n            lowpass_filter: 100 * Token.UINT8.get(buf, off + 1),\n            track_peak: track_peak === 0 ? null : track_peak / 2 ** 23,\n            track_gain: ReplayGain.get(buf, 6),\n            album_gain: ReplayGain.get(buf, 8),\n            music_length: Token.UINT32_BE.get(buf, off + 20),\n            music_crc: Token.UINT8.get(buf, off + 24),\n            header_crc: Token.UINT16_BE.get(buf, off + 24)\n        };\n    }\n};\n//# sourceMappingURL=ExtendedLameHeader.js.map","import * as Token from 'token-types';\nimport * as util from '../common/Util.js';\nimport { ExtendedLameHeader } from './ExtendedLameHeader.js';\n/**\n * Info Tag: Xing, LAME\n */\nexport const InfoTagHeaderTag = new Token.StringType(4, 'ascii');\n/**\n * LAME TAG value\n * Did not find any official documentation for this\n * Value e.g.: \"3.98.4\"\n */\nexport const LameEncoderVersion = new Token.StringType(6, 'ascii');\n/**\n * Info Tag\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n */\nexport const XingHeaderFlags = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            frames: util.isBitSet(buf, off, 31),\n            bytes: util.isBitSet(buf, off, 30),\n            toc: util.isBitSet(buf, off, 29),\n            vbrScale: util.isBitSet(buf, off, 28)\n        };\n    }\n};\n// /**\n//  * XING Header Tag\n//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n//  */\nexport async function readXingHeader(tokenizer) {\n    const flags = await tokenizer.readToken(XingHeaderFlags);\n    const xingInfoTag = { numFrames: null, streamSize: null, vbrScale: null };\n    if (flags.frames) {\n        xingInfoTag.numFrames = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    if (flags.bytes) {\n        xingInfoTag.streamSize = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    if (flags.toc) {\n        xingInfoTag.toc = new Uint8Array(100);\n        await tokenizer.readBuffer(xingInfoTag.toc);\n    }\n    if (flags.vbrScale) {\n        xingInfoTag.vbrScale = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    const lameTag = await tokenizer.peekToken(new Token.StringType(4, 'ascii'));\n    if (lameTag === 'LAME') {\n        await tokenizer.ignore(4);\n        xingInfoTag.lame = {\n            version: await tokenizer.readToken(new Token.StringType(5, 'ascii'))\n        };\n        const match = xingInfoTag.lame.version.match(/\\d+.\\d+/g);\n        if (match !== null) {\n            const majorMinorVersion = match[0]; // e.g. 3.97\n            const version = majorMinorVersion.split('.').map(n => Number.parseInt(n, 10));\n            if (version[0] >= 3 && version[1] >= 90) {\n                xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader);\n            }\n        }\n    }\n    return xingInfoTag;\n}\n//# sourceMappingURL=XingTag.js.map","import * as Token from 'token-types';\nimport { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport * as common from '../common/Util.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { InfoTagHeaderTag, LameEncoderVersion, readXingHeader } from './XingTag.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:mpeg');\nexport class MpegContentError extends makeUnexpectedFileContentError('MPEG') {\n}\n/**\n * Cache buffer size used for searching synchronization preabmle\n */\nconst maxPeekLen = 1024;\n/**\n * MPEG-4 Audio definitions\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\n */\nconst MPEG4 = {\n    /**\n     * Audio Object Types\n     */\n    AudioObjectTypes: [\n        'AAC Main',\n        'AAC LC', // Low Complexity\n        'AAC SSR', // Scalable Sample Rate\n        'AAC LTP' // Long Term Prediction\n    ],\n    /**\n     * Sampling Frequencies\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\n     */\n    SamplingFrequencies: [\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, null, null, -1\n    ]\n    /**\n     * Channel Configurations\n     */\n};\nconst MPEG4_ChannelConfigurations = [\n    undefined,\n    ['front-center'],\n    ['front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right', 'back-center'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\n];\n/**\n * MPEG Audio Layer I/II/III frame header\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\n */\nclass MpegFrameHeader {\n    constructor(buf, off) {\n        // E(15,12): Bitrate index\n        this.bitrateIndex = null;\n        // F(11,10): Sampling rate frequency index\n        this.sampRateFreqIndex = null;\n        // G(9): Padding bit\n        this.padding = null;\n        // H(8): Private bit\n        this.privateBit = null;\n        // I(7,6): Channel Mode\n        this.channelModeIndex = null;\n        // J(5,4): Mode extension (Only used in Joint stereo)\n        this.modeExtension = null;\n        // L(2): Original\n        this.isOriginalMedia = null;\n        this.version = null;\n        this.bitrate = null;\n        this.samplingRate = null;\n        this.frameLength = 0;\n        // B(20,19): MPEG Audio versionIndex ID\n        this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\n        // C(18,17): Layer description\n        this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\n        if (this.versionIndex > 1 && this.layer === 0) {\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n        }\n        else {\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\n        }\n        // D(16): Protection bit (if true 16-bit CRC follows header)\n        this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\n    }\n    calcDuration(numFrames) {\n        return this.samplingRate == null ? null : (numFrames * this.calcSamplesPerFrame() / this.samplingRate);\n    }\n    calcSamplesPerFrame() {\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n    }\n    calculateSideInfoLength() {\n        if (this.layer !== 3)\n            return 2;\n        if (this.channelModeIndex === 3) {\n            // mono\n            if (this.version === 1) {\n                return 17;\n            }\n            if (this.version === 2 || this.version === 2.5) {\n                return 9;\n            }\n        }\n        else {\n            if (this.version === 1) {\n                return 32;\n            }\n            if (this.version === 2 || this.version === 2.5) {\n                return 17;\n            }\n        }\n        return null;\n    }\n    calcSlotSize() {\n        return [null, 4, 1, 1][this.layer];\n    }\n    parseMpegHeader(buf, off) {\n        this.container = 'MPEG';\n        // E(15,12): Bitrate index\n        this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\n        // F(11,10): Sampling rate frequency index\n        this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\n        // G(9): Padding bit\n        this.padding = common.isBitSet(buf, off + 2, 6);\n        // H(8): Private bit\n        this.privateBit = common.isBitSet(buf, off + 2, 7);\n        // I(7,6): Channel Mode\n        this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\n        // J(5,4): Mode extension (Only used in Joint stereo)\n        this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\n        // K(3): Copyright\n        this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\n        // L(2): Original\n        this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n        this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\n        // Calculate bitrate\n        const bitrateInKbps = this.calcBitrate();\n        if (!bitrateInKbps) {\n            throw new MpegContentError('Cannot determine bit-rate');\n        }\n        this.bitrate = bitrateInKbps * 1000;\n        // Calculate sampling rate\n        this.samplingRate = this.calcSamplingRate();\n        if (this.samplingRate == null) {\n            throw new MpegContentError('Cannot determine sampling-rate');\n        }\n    }\n    parseAdtsHeader(buf, off) {\n        debug(\"layer=0 => ADTS\");\n        this.version = this.versionIndex === 2 ? 4 : 2;\n        this.container = `ADTS/MPEG-${this.version}`;\n        const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\n        this.codec = 'AAC';\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n        debug(`MPEG-4 audio-codec=${this.codec}`);\n        const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n        debug(`sampling-rate=${this.samplingRate}`);\n        const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n        debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join('+') : '?'}`);\n        this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n    }\n    calcBitrate() {\n        if (this.bitrateIndex === 0x00 || // free\n            this.bitrateIndex === 0x0F) { // reserved\n            return null;\n        }\n        if (this.version && this.bitrateIndex) {\n            const codecIndex = 10 * Math.floor(this.version) + this.layer;\n            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n        }\n        return null;\n    }\n    calcSamplingRate() {\n        if (this.sampRateFreqIndex === 0x03 || this.version === null || this.sampRateFreqIndex == null)\n            return null; // 'reserved'\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n    }\n}\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n    1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\n    2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\n    3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\n    4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\n    5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\n    6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\n    7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\n    8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\n    9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\n    10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\n    11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\n    12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\n    13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\n    14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n    1: { 0: 44100, 1: 48000, 2: 32000 },\n    2: { 0: 22050, 1: 24000, 2: 16000 },\n    2.5: { 0: 11025, 1: 12000, 2: 8000 }\n};\nMpegFrameHeader.samplesInFrameTable = [\n    /* Layer   I    II   III */\n    [0, 384, 1152, 1152], // MPEG-1\n    [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\n * MPEG Audio Layer I/II/III\n */\nconst FrameHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return new MpegFrameHeader(buf, off);\n    }\n};\nfunction getVbrCodecProfile(vbrScale) {\n    return `V${Math.floor((100 - vbrScale) / 10)}`;\n}\nexport class MpegParser extends AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.frameCount = 0;\n        this.syncFrameCount = -1;\n        this.countSkipFrameData = 0;\n        this.totalDataLength = 0;\n        this.bitrates = [];\n        this.offset = 0;\n        this.frame_size = 0;\n        this.crc = null;\n        this.calculateEofDuration = false;\n        this.samplesPerFrame = null;\n        this.buf_frame_header = new Uint8Array(4);\n        /**\n         * Number of bytes already parsed since beginning of stream / file\n         */\n        this.mpegOffset = null;\n        this.syncPeek = {\n            buf: new Uint8Array(maxPeekLen),\n            len: 0\n        };\n    }\n    /**\n     * Called after ID3 headers have been parsed\n     */\n    async postId3v2Parse() {\n        this.metadata.setFormat('lossless', false);\n        this.metadata.setAudioOnly();\n        try {\n            let quit = false;\n            while (!quit) {\n                await this.sync();\n                quit = await this.parseCommonMpegHeader();\n            }\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"End-of-stream\");\n                if (this.calculateEofDuration) {\n                    if (this.samplesPerFrame !== null) {\n                        const numberOfSamples = this.frameCount * this.samplesPerFrame;\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                        if (this.metadata.format.sampleRate) {\n                            const duration = numberOfSamples / this.metadata.format.sampleRate;\n                            debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n                            this.metadata.setFormat('duration', duration);\n                        }\n                    }\n                }\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    /**\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\n     */\n    finalize() {\n        const format = this.metadata.format;\n        const hasID3v1 = !!this.metadata.native.ID3v1;\n        if (this.mpegOffset !== null) {\n            if (format.duration && this.tokenizer.fileInfo.size) {\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n                if (format.codecProfile && format.codecProfile[0] === 'V') {\n                    this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n                }\n            }\n            if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n                if (this.frame_size !== null && this.samplesPerFrame !== null) {\n                    const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                    if (format.sampleRate && !format.duration) {\n                        const duration = numberOfSamples / format.sampleRate;\n                        debug(\"Calculate CBR duration based on file size: %s\", duration);\n                        this.metadata.setFormat('duration', duration);\n                    }\n                }\n            }\n        }\n    }\n    async sync() {\n        let gotFirstSync = false;\n        while (true) {\n            let bo = 0;\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\n            if (this.syncPeek.len <= 163) {\n                throw new EndOfStreamError();\n            }\n            while (true) {\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\n                    await this.tokenizer.ignore(bo);\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n                    if (this.syncFrameCount === this.frameCount) {\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n                        this.frameCount = 0;\n                        this.frame_size = 0;\n                    }\n                    this.syncFrameCount = this.frameCount;\n                    return; // sync\n                }\n                gotFirstSync = false;\n                bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n                if (bo === -1) {\n                    if (this.syncPeek.len < this.syncPeek.buf.length) {\n                        throw new EndOfStreamError();\n                    }\n                    await this.tokenizer.ignore(this.syncPeek.len);\n                    break; // continue with next buffer\n                }\n                ++bo;\n                gotFirstSync = true;\n            }\n        }\n    }\n    /**\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseCommonMpegHeader() {\n        if (this.frameCount === 0) {\n            this.mpegOffset = this.tokenizer.position - 1;\n        }\n        await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), { length: 3 });\n        let header;\n        try {\n            header = FrameHeader.get(this.buf_frame_header, 0);\n        }\n        catch (err) {\n            await this.tokenizer.ignore(1);\n            if (err instanceof Error) {\n                this.metadata.addWarning(`Parse error: ${err.message}`);\n                return false; // sync\n            }\n            throw err;\n        }\n        await this.tokenizer.ignore(3);\n        this.metadata.setFormat('container', header.container);\n        this.metadata.setFormat('codec', header.codec);\n        this.metadata.setFormat('lossless', false);\n        this.metadata.setFormat('sampleRate', header.samplingRate);\n        this.frameCount++;\n        return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\n    }\n    /**\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseAudioFrameHeader(header) {\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n        this.metadata.setFormat('bitrate', header.bitrate);\n        if (this.frameCount < 20 * 10000) {\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n        }\n        const slot_size = header.calcSlotSize();\n        if (slot_size === null) {\n            throw new MpegContentError('invalid slot_size');\n        }\n        const samples_per_frame = header.calcSamplesPerFrame();\n        debug(`samples_per_frame=${samples_per_frame}`);\n        const bps = samples_per_frame / 8.0;\n        if (header.bitrate !== null && header.samplingRate != null) {\n            const fsize = (bps * header.bitrate / header.samplingRate) + ((header.padding) ? slot_size : 0);\n            this.frame_size = Math.floor(fsize);\n        }\n        this.audioFrameHeader = header;\n        if (header.bitrate !== null) {\n            this.bitrates.push(header.bitrate);\n        }\n        // xtra header only exists in first frame\n        if (this.frameCount === 1) {\n            this.offset = FrameHeader.len;\n            await this.skipSideInformation();\n            return false;\n        }\n        if (this.frameCount === 3) {\n            // the stream is CBR if the first 3 frame bitrates are the same\n            if (this.areAllSame(this.bitrates)) {\n                // Actual calculation will be done in finalize\n                this.samplesPerFrame = samples_per_frame;\n                this.metadata.setFormat('codecProfile', 'CBR');\n                if (this.tokenizer.fileInfo.size)\n                    return true; // Will calculate duration based on the file size\n            }\n            else if (this.metadata.format.duration) {\n                return true; // We already got the duration, stop processing MPEG stream any further\n            }\n            if (!this.options.duration) {\n                return true; // Enforce duration not enabled, stop processing entire stream\n            }\n        }\n        // once we know the file is VBR attach listener to end of\n        // stream so we can do the duration calculation when we\n        // have counted all the frames\n        if (this.options.duration && this.frameCount === 4) {\n            this.samplesPerFrame = samples_per_frame;\n            this.calculateEofDuration = true;\n        }\n        this.offset = 4;\n        if (header.isProtectedByCRC) {\n            await this.parseCrc();\n            return false;\n        }\n        await this.skipSideInformation();\n        return false;\n    }\n    async parseAdts(header) {\n        const buf = new Uint8Array(3);\n        await this.tokenizer.readBuffer(buf);\n        header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\n        this.totalDataLength += header.frameLength;\n        this.samplesPerFrame = 1024;\n        if (header.samplingRate !== null) {\n            const framesPerSec = header.samplingRate / this.samplesPerFrame;\n            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n            this.metadata.setFormat('bitrate', bitrate);\n            debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n        }\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n        // Consume remaining header and frame data\n        if (this.frameCount === 3) {\n            this.metadata.setFormat('codecProfile', header.codecProfile);\n            if (header.mp4ChannelConfig) {\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n            }\n            if (this.options.duration) {\n                this.calculateEofDuration = true;\n            }\n            else {\n                return true; // Stop parsing after the third frame\n            }\n        }\n        return false;\n    }\n    async parseCrc() {\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n        this.offset += 2;\n        return this.skipSideInformation();\n    }\n    async skipSideInformation() {\n        if (this.audioFrameHeader) {\n            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\n            if (sideinfo_length !== null) {\n                await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\n                // side information\n                this.offset += sideinfo_length;\n                await this.readXtraInfoHeader();\n                return;\n            }\n        }\n    }\n    async readXtraInfoHeader() {\n        const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);\n        this.offset += InfoTagHeaderTag.len; // 12\n        switch (headerTag) {\n            case 'Info':\n                this.metadata.setFormat('codecProfile', 'CBR');\n                return this.readXingInfoHeader();\n            case 'Xing': {\n                const infoTag = await this.readXingInfoHeader();\n                if (infoTag.vbrScale !== null) {\n                    const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n                    this.metadata.setFormat('codecProfile', codecProfile);\n                }\n                return null;\n            }\n            case 'Xtra':\n                // ToDo: ???\n                break;\n            case 'LAME': {\n                const version = await this.tokenizer.readToken(LameEncoderVersion);\n                if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {\n                    this.offset += LameEncoderVersion.len;\n                    this.metadata.setFormat('tool', `LAME ${version}`);\n                    await this.skipFrameData(this.frame_size - this.offset);\n                    return null;\n                }\n                this.metadata.addWarning('Corrupt LAME header');\n                break;\n            }\n            // ToDo: ???\n        }\n        // ToDo: promise duration???\n        const frameDataLeft = this.frame_size - this.offset;\n        if (frameDataLeft < 0) {\n            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);\n        }\n        else {\n            await this.skipFrameData(frameDataLeft);\n        }\n        return null;\n    }\n    /**\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n     * @returns {Promise<string>}\n     */\n    async readXingInfoHeader() {\n        const offset = this.tokenizer.position;\n        const infoTag = await readXingHeader(this.tokenizer);\n        this.offset += this.tokenizer.position - offset;\n        if (infoTag.lame) {\n            this.metadata.setFormat('tool', `LAME ${common.stripNulls(infoTag.lame.version)}`);\n            if (infoTag.lame.extended) {\n                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\n                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\n                if (infoTag.lame.extended.track_gain) {\n                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\n                }\n                if (infoTag.lame.extended.album_gain) {\n                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\n                }\n                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\n            }\n        }\n        if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n            this.metadata.setFormat('duration', duration);\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\n            return infoTag;\n        }\n        // frames field is not present\n        const frameDataLeft = this.frame_size - this.offset;\n        await this.skipFrameData(frameDataLeft);\n        return infoTag;\n    }\n    async skipFrameData(frameDataLeft) {\n        if (frameDataLeft < 0)\n            throw new MpegContentError('frame-data-left cannot be negative');\n        await this.tokenizer.ignore(frameDataLeft);\n        this.countSkipFrameData += frameDataLeft;\n    }\n    areAllSame(array) {\n        const first = array[0];\n        return array.every(element => {\n            return element === first;\n        });\n    }\n}\n//# sourceMappingURL=MpegParser.js.map"],"names":["ReplayGain","buf","off","gain_type","common.getBitAllignedNumber","sign","gain_adj","ExtendedLameHeader","track_peak","Token.UINT32_BE","Token.UINT8","Token.UINT16_BE","InfoTagHeaderTag","Token.StringType","LameEncoderVersion","XingHeaderFlags","util.isBitSet","readXingHeader","tokenizer","flags","xingInfoTag","match","version","n","debug","initDebug","MpegContentError","makeUnexpectedFileContentError","maxPeekLen","MPEG4","MPEG4_ChannelConfigurations","MpegFrameHeader","common.isBitSet","numFrames","bitrateInKbps","profileIndex","samplingFrequencyIndex","channelIndex","codecIndex","FrameHeader","getVbrCodecProfile","vbrScale","MpegParser","AbstractID3Parser","quit","err","EndOfStreamError","numberOfSamples","duration","format","hasID3v1","mpegSize","gotFirstSync","bo","header","slot_size","samples_per_frame","bps","fsize","framesPerSec","bitrate","Token.INT16_BE","sideinfo_length","Token.Uint8ArrayType","headerTag","infoTag","codecProfile","frameDataLeft","offset","common.stripNulls","array","first","element"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}