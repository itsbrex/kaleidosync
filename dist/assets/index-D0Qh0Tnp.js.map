{"version":3,"file":"index-D0Qh0Tnp.js","sources":["../../node_modules/@wearesage/shared/dist/index.mjs"],"sourcesContent":["// src/enums.ts\nvar UserRole = {\n  USER: 0,\n  ADMIN: 1,\n  ARTIST: 2,\n  SUBSCRIBER: 3,\n  TEAM: 4\n};\nvar ADMIN_WALLET = \"6Qxu5cRDNFEZvYtgtvo27tdg7LuT5wuX7THqqPbBWJmT\";\nvar SpecialWallets = {\n  SHADER_TOM: ADMIN_WALLET\n  // Add more special users here as needed\n};\nvar UserStatus = {\n  OFFLINE: 0,\n  ONLINE: 1,\n  AWAY: 2,\n  BUSY: 3\n};\nvar ActivityType = {\n  IDLE: 0,\n  CODING: 1,\n  LISTENING: 2,\n  BROWSING: 3\n};\nvar CurrentPage = {\n  HOME: 0,\n  VISUALIZER: 1,\n  SKETCHES: 2,\n  STUDIES: 3,\n  PROFILE: 4,\n  SETTINGS: 5,\n  // Admin pages\n  DASHBOARD: 6,\n  PROJECTS: 7,\n  PROJECT_DETAIL: 8,\n  // UI pages\n  DESIGN: 9,\n  GIST: 10,\n  AUDIUS_HOME: 11,\n  AUDIUS_PLAYLIST_DETAIL: 12,\n  AUDIUS_USER_DETAIL: 13,\n  PAGE_NOT_FOUND: 14\n};\nvar AudioSource = {\n  NONE: 0,\n  SPOTIFY: 1,\n  AUDIUS: 2,\n  RADIO_PARADISE: 3,\n  MICROPHONE: 4,\n  FILE: 5,\n  BROWSER_AUDIO: 6,\n  KEXP: 7\n};\nvar RadioSource = {\n  RADIO_PARADISE: 0,\n  KEXP: 1\n};\nvar RadioParadiseStation = {\n  MAIN_MIX: 0,\n  MELLOW_MIX: 1,\n  ROCK_MIX: 2,\n  GLOBAL_MIX: 3\n};\nvar RadioStreamUrls = {\n  RADIO_PARADISE: {\n    [RadioParadiseStation.MAIN_MIX]: {\n      mp3: \"http://stream.radioparadise.com/aac-320\",\n      flac: \"http://stream.radioparadise.com/flac\"\n    },\n    [RadioParadiseStation.MELLOW_MIX]: {\n      mp3: \"http://stream.radioparadise.com/mellow-320\",\n      flac: \"http://stream.radioparadise.com/mellow-flac\"\n    },\n    [RadioParadiseStation.ROCK_MIX]: {\n      mp3: \"http://stream.radioparadise.com/rock-320\",\n      flac: \"http://stream.radioparadise.com/rock-flac\"\n    },\n    [RadioParadiseStation.GLOBAL_MIX]: {\n      mp3: \"http://stream.radioparadise.com/global-320\",\n      flac: \"http://stream.radioparadise.com/global-flac\"\n    }\n  },\n  KEXP: {\n    mp3: \"https://kexp.streamguys1.com/kexp160.aac\"\n  }\n};\nvar PlaybackState = {\n  STOPPED: 0,\n  PLAYING: 1,\n  PAUSED: 2,\n  BUFFERING: 3\n};\nvar SpaceType = {\n  GLOBAL_ACTIVE: 0,\n  CODING_ROOM: 1,\n  LISTENING_PARTY: 2,\n  CREATIVE_LAB: 3,\n  PRIVATE_ROOM: 4\n};\nvar SpaceVisibility = {\n  PUBLIC: 0,\n  UNLISTED: 1,\n  PRIVATE: 2\n};\nvar DeviceType = {\n  DESKTOP: 0,\n  MOBILE: 1,\n  TABLET: 2,\n  VR: 3,\n  WATCH: 4,\n  TV: 5,\n  CONSOLE: 6\n};\nvar ClientPlatform = {\n  WEB: 0,\n  ELECTRON: 1,\n  MOBILE_APP: 2\n};\nvar ContentVisibility = {\n  PRIVATE: 0,\n  PUBLIC: 1,\n  UNLISTED: 2,\n  FRIENDS_ONLY: 3\n};\nvar ShaderCategory = {\n  UNCATEGORIZED: 0,\n  VISUAL_MUSIC: 1,\n  ABSTRACT: 2,\n  GENERATIVE: 3,\n  INTERACTIVE: 4,\n  EXPERIMENTAL: 5\n};\nvar TaskStatus = {\n  TODO: 0,\n  IN_PROGRESS: 1,\n  COMPLETED: 2,\n  CANCELLED: 3\n};\nvar TaskPriority = {\n  LOW: 0,\n  MEDIUM: 1,\n  HIGH: 2,\n  URGENT: 3\n};\nvar ProjectStatus = {\n  ACTIVE: 0,\n  ARCHIVED: 1,\n  COMPLETED: 2,\n  ON_HOLD: 3\n};\nfunction enumToString(enumObject, value) {\n  const key = Object.keys(enumObject).find((k) => enumObject[k] === value);\n  return key || \"UNKNOWN\";\n}\nfunction enumKeyToLabel(enumKey) {\n  return enumKey.split(\"_\").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(\" \");\n}\nfunction getEnumValues(enumObject) {\n  return Object.values(enumObject).filter((v) => typeof v === \"number\");\n}\nfunction isValidEnumValue(enumObject, value) {\n  return getEnumValues(enumObject).includes(value);\n}\nvar UserStateField = {\n  STATUS: 0,\n  // online/offline/away/busy\n  PAGE: 1,\n  // current page/route  \n  AUDIO_SOURCE: 2,\n  // spotify/audius/etc\n  AUDIO_TRACK: 3,\n  // current track hash\n  AUDIO_POSITION: 4,\n  // playback timestamp\n  GEO_LAT: 5,\n  // latitude for globe\n  GEO_LNG: 6,\n  // longitude for globe  \n  DEVICE_TYPE: 7,\n  // desktop/mobile/tablet\n  CLIENT_PLATFORM: 8,\n  // web/electron/mobile\n  LAST_SEEN: 9,\n  // timestamp\n  ACTIVITY_TYPE: 10,\n  // coding/listening/browsing\n  SHADER_ID: 11,\n  // current shader being viewed/edited\n  PROJECT_ID: 12\n  // current project space\n};\nvar AnalyticsMetric = {\n  PAGE_VIEW: 0,\n  SHADER_VIEW: 1,\n  TRACK_PLAY: 2,\n  PROJECT_JOIN: 3,\n  COLLABORATION_EVENT: 4,\n  AUDIO_SOURCE_SWITCH: 5,\n  GLOBE_INTERACTION: 6\n};\nvar GeoRegion = {\n  NORTH_AMERICA: 0,\n  SOUTH_AMERICA: 1,\n  EUROPE: 2,\n  ASIA: 3,\n  AFRICA: 4,\n  OCEANIA: 5,\n  ANTARCTICA: 6\n};\nvar AppTarget = {\n  WEB: 0,\n  // Standard web app (kaleidosync.com)\n  PWA: 1,\n  // Progressive Web App with service worker\n  CHROME: 2,\n  // Chrome extension overlay\n  FIREFOX: 3,\n  // Firefox extension\n  EDGE: 4,\n  // Microsoft Edge extension\n  ELECTRON: 5,\n  // Electron desktop app\n  WIDGET: 6,\n  // Embeddable iframe widget\n  CDN: 7,\n  // CDN-hosted script for any website\n  DEV: 8\n  // Development mode with hot reload\n};\nvar OperatingSystem = {\n  MACOS: 13,\n  IOS: 14,\n  WINDOWS: 15,\n  LINUX: 16,\n  ANDROID: 17,\n  WINDOWS_MOBILE: 18,\n  CHROME_OS: 19,\n  UBUNTU: 20,\n  DEBIAN: 21,\n  FEDORA: 22,\n  ARCH: 23\n};\nvar Country = {\n  UNITED_STATES: 24,\n  CANADA: 25,\n  UNITED_KINGDOM: 26,\n  GERMANY: 27,\n  FRANCE: 28,\n  JAPAN: 29,\n  AUSTRALIA: 30,\n  BRAZIL: 31,\n  INDIA: 32,\n  CHINA: 33,\n  RUSSIA: 34,\n  ITALY: 35,\n  SPAIN: 36,\n  NETHERLANDS: 37,\n  SWEDEN: 38,\n  NORWAY: 39,\n  DENMARK: 40,\n  FINLAND: 41,\n  SOUTH_KOREA: 42,\n  SINGAPORE: 43,\n  NEW_ZEALAND: 44,\n  SWITZERLAND: 45,\n  AUSTRIA: 46,\n  BELGIUM: 47,\n  PORTUGAL: 48,\n  IRELAND: 49,\n  POLAND: 50,\n  CZECH_REPUBLIC: 51,\n  HUNGARY: 52,\n  GREECE: 53,\n  TURKEY: 54,\n  ISRAEL: 55,\n  UAE: 56,\n  SAUDI_ARABIA: 57,\n  SOUTH_AFRICA: 58,\n  MEXICO: 59,\n  ARGENTINA: 60,\n  CHILE: 61,\n  COLOMBIA: 62,\n  PERU: 63,\n  THAILAND: 64,\n  VIETNAM: 65,\n  PHILIPPINES: 66,\n  INDONESIA: 67,\n  MALAYSIA: 68,\n  TAIWAN: 69,\n  HONG_KONG: 70\n};\nvar ShaderType = {\n  FRAGMENT: 71,\n  VERTEX: 72,\n  COMPUTE: 73,\n  GEOMETRY: 74,\n  TESSELLATION: 75\n};\nvar VisualTag = {\n  AUDIO_REACTIVE: 76,\n  GENERATIVE: 77,\n  PARTICLE_SYSTEM: 78,\n  FRACTAL: 79,\n  CYBERPUNK: 80,\n  ABSTRACT: 81,\n  GEOMETRIC: 82,\n  ORGANIC: 83,\n  GLITCH: 84,\n  MINIMALIST: 85,\n  COLORFUL: 86,\n  MONOCHROME: 87,\n  PSYCHEDELIC: 88,\n  RETRO: 89,\n  FUTURISTIC: 90,\n  NATURE: 91,\n  SPACE: 92,\n  UNDERWATER: 93,\n  FIRE: 94,\n  ICE: 95,\n  LIGHTNING: 96,\n  SMOKE: 97,\n  FLUID: 98,\n  CRYSTAL: 99,\n  NEON: 100\n};\nvar PerformanceLevel = {\n  LOW: 101,\n  MEDIUM: 102,\n  HIGH: 103,\n  ULTRA: 104,\n  MOBILE_OPTIMIZED: 105,\n  VR_OPTIMIZED: 106,\n  EXPERIMENTAL: 107\n};\nvar Quality = {\n  SD: 108,\n  // 480p\n  HD: 109,\n  // 720p\n  FHD: 110,\n  // 1080p\n  QHD: 111,\n  // 1440p\n  UHD_4K: 112,\n  // 2160p\n  UHD_8K: 113,\n  // 4320p\n  MOBILE: 114,\n  // Mobile optimized\n  RETINA: 115\n  // High DPI displays\n};\nvar Framework = {\n  THREEJS: 116,\n  WEBGL: 117,\n  WEBGPU: 118,\n  SHADERTOY: 119,\n  OPENGL: 120,\n  VULKAN: 121,\n  DIRECTX: 122,\n  METAL: 123,\n  GLSL: 124,\n  HLSL: 125,\n  WGSL: 126,\n  P5JS: 127,\n  PROCESSING: 128,\n  UNITY: 129,\n  UNREAL: 130\n};\nvar TimePeriod = {\n  TODAY: 131,\n  YESTERDAY: 132,\n  WEEK: 133,\n  MONTH: 134,\n  QUARTER: 135,\n  YEAR: 136,\n  ALL_TIME: 137,\n  LAST_7_DAYS: 138,\n  LAST_30_DAYS: 139,\n  LAST_90_DAYS: 140,\n  LAST_365_DAYS: 141\n};\nvar SortBy = {\n  CREATED_AT: 142,\n  UPDATED_AT: 143,\n  POPULARITY: 144,\n  LIKES: 145,\n  VIEWS: 146,\n  ALPHABETICAL: 147,\n  RATING: 148,\n  TRENDING: 149,\n  FEATURED: 150,\n  RECENT: 151,\n  DOWNLOADS: 152,\n  COMMENTS: 153,\n  SHARES: 154,\n  DURATION: 155,\n  SIZE: 156,\n  COMPLEXITY: 157\n};\nvar SortOrder = {\n  ASC: 158,\n  DESC: 159,\n  ASCENDING: 160,\n  DESCENDING: 161\n};\nvar CollaborationRole = {\n  OWNER: 162,\n  COLLABORATOR: 163,\n  VIEWER: 164,\n  COMMENTER: 165,\n  EDITOR: 166,\n  ADMIN: 167,\n  MODERATOR: 168,\n  GUEST: 169\n};\nvar RouterModeMap = {\n  [AppTarget.WEB]: \"history\",\n  [AppTarget.PWA]: \"history\",\n  [AppTarget.CHROME]: \"overlay\",\n  [AppTarget.FIREFOX]: \"overlay\",\n  [AppTarget.EDGE]: \"overlay\",\n  [AppTarget.ELECTRON]: \"memory\",\n  [AppTarget.WIDGET]: \"memory\",\n  [AppTarget.CDN]: \"memory\",\n  [AppTarget.DEV]: \"history\"\n};\nvar SocketCore = {\n  CONNECTED: 170,\n  DISCONNECTED: 171,\n  AUTHENTICATED: 172,\n  UNAUTHENTICATED: 173,\n  ERROR: 174,\n  RECONNECTING: 175,\n  TIMEOUT: 176\n};\nvar SocketRoom = {\n  JOINED: 177,\n  LEFT: 178,\n  USER_JOINED: 179,\n  USER_LEFT: 180,\n  ROOM_CREATED: 181,\n  ROOM_DESTROYED: 182\n};\nvar SocketEntity = {\n  PROJECT: 183,\n  BUCKET: 184,\n  TASK: 185,\n  STUDY: 186,\n  USER: 187,\n  COLLABORATION: 188,\n  MESSAGE: 189,\n  NOTIFICATION: 190,\n  SPACE: 191,\n  AUDIO: 192\n};\nvar SocketCrud = {\n  CREATE: 193,\n  UPDATE: 194,\n  DELETE: 195,\n  MOVE: 196,\n  RESTORE: 197,\n  ARCHIVE: 198\n};\nvar SocketSocial = {\n  FOLLOW: 199,\n  UNFOLLOW: 200,\n  INVITE: 201,\n  REMOVE: 202,\n  ACCEPT: 203,\n  REJECT: 204,\n  PROMOTE: 205,\n  DEMOTE: 206\n};\nvar SocketActivity = {\n  CURSOR_MOVE: 207,\n  DRAG_START: 208,\n  DRAG_END: 209,\n  TYPING_START: 210,\n  TYPING_END: 211,\n  PRESENCE_UPDATE: 212,\n  STATUS_CHANGE: 213\n};\nfunction generateSocketEvent(entity, action) {\n  const entityName = enumToString(SocketEntity, entity).toLowerCase();\n  const actionName = enumToString({ ...SocketCrud, ...SocketSocial, ...SocketActivity, ...SocketCore, ...SocketRoom }, action).toLowerCase();\n  return `${entityName}:${actionName}`;\n}\nvar SocketEvents = {\n  // Core connection events\n  CORE_CONNECTED: \"core:connected\",\n  CORE_DISCONNECTED: \"core:disconnected\",\n  CORE_AUTHENTICATED: \"core:authenticated\",\n  CORE_ERROR: \"core:error\",\n  // Space management\n  SPACE_JOINED: \"space:joined\",\n  SPACE_LEFT: \"space:left\",\n  SPACE_USER_JOINED: \"space:user:joined\",\n  SPACE_USER_LEFT: \"space:user:left\",\n  // Space entity CRUD - Projects\n  SPACE_PROJECT_CREATE: \"space:project:create\",\n  SPACE_PROJECT_UPDATE: \"space:project:update\",\n  SPACE_PROJECT_DELETE: \"space:project:delete\",\n  SPACE_PROJECT_ARCHIVE: \"space:project:archive\",\n  // Space entity CRUD - Buckets  \n  SPACE_BUCKET_CREATE: \"space:bucket:create\",\n  SPACE_BUCKET_UPDATE: \"space:bucket:update\",\n  SPACE_BUCKET_DELETE: \"space:bucket:delete\",\n  // Space entity CRUD - Tasks\n  SPACE_TASK_CREATE: \"space:task:create\",\n  SPACE_TASK_UPDATE: \"space:task:update\",\n  SPACE_TASK_DELETE: \"space:task:delete\",\n  SPACE_TASK_MOVE: \"space:task:move\",\n  // Space entity CRUD - Studies\n  SPACE_STUDY_CREATE: \"space:study:create\",\n  SPACE_STUDY_UPDATE: \"space:study:update\",\n  SPACE_STUDY_DELETE: \"space:study:delete\",\n  // Space social actions\n  SPACE_USER_FOLLOW: \"space:user:follow\",\n  SPACE_USER_UNFOLLOW: \"space:user:unfollow\",\n  // Space collaboration management\n  SPACE_COLLABORATION_INVITE: \"space:collaboration:invite\",\n  SPACE_COLLABORATION_REMOVE: \"space:collaboration:remove\",\n  SPACE_COLLABORATION_ACCEPT: \"space:collaboration:accept\",\n  SPACE_COLLABORATION_REJECT: \"space:collaboration:reject\",\n  // Space real-time activities\n  SPACE_CURSOR_MOVE: \"space:cursor:move\",\n  SPACE_DRAG_START: \"space:drag:start\",\n  SPACE_DRAG_END: \"space:drag:end\",\n  SPACE_TYPING_START: \"space:typing:start\",\n  SPACE_TYPING_END: \"space:typing:end\",\n  SPACE_PRESENCE_UPDATE: \"space:presence:update\",\n  // Space messaging\n  SPACE_MESSAGE_SEND: \"space:message:create\",\n  SPACE_MESSAGE_UPDATE: \"space:message:update\",\n  SPACE_MESSAGE_DELETE: \"space:message:delete\",\n  // Space notifications\n  SPACE_NOTIFICATION_CREATE: \"space:notification:create\",\n  SPACE_NOTIFICATION_UPDATE: \"space:notification:update\",\n  SPACE_NOTIFICATION_DELETE: \"space:notification:delete\"\n};\nvar SocketEventCategories = {\n  CORE: [SocketEvents.CORE_CONNECTED, SocketEvents.CORE_DISCONNECTED, SocketEvents.CORE_AUTHENTICATED, SocketEvents.CORE_ERROR],\n  SPACE_MANAGEMENT: [SocketEvents.SPACE_JOINED, SocketEvents.SPACE_LEFT, SocketEvents.SPACE_USER_JOINED, SocketEvents.SPACE_USER_LEFT],\n  SPACE_PROJECT_CRUD: [SocketEvents.SPACE_PROJECT_CREATE, SocketEvents.SPACE_PROJECT_UPDATE, SocketEvents.SPACE_PROJECT_DELETE, SocketEvents.SPACE_PROJECT_ARCHIVE],\n  SPACE_BUCKET_CRUD: [SocketEvents.SPACE_BUCKET_CREATE, SocketEvents.SPACE_BUCKET_UPDATE, SocketEvents.SPACE_BUCKET_DELETE],\n  SPACE_TASK_CRUD: [SocketEvents.SPACE_TASK_CREATE, SocketEvents.SPACE_TASK_UPDATE, SocketEvents.SPACE_TASK_DELETE, SocketEvents.SPACE_TASK_MOVE],\n  SPACE_STUDY_CRUD: [SocketEvents.SPACE_STUDY_CREATE, SocketEvents.SPACE_STUDY_UPDATE, SocketEvents.SPACE_STUDY_DELETE],\n  SPACE_SOCIAL: [SocketEvents.SPACE_USER_FOLLOW, SocketEvents.SPACE_USER_UNFOLLOW, SocketEvents.SPACE_COLLABORATION_INVITE, SocketEvents.SPACE_COLLABORATION_REMOVE],\n  SPACE_ACTIVITY: [SocketEvents.SPACE_CURSOR_MOVE, SocketEvents.SPACE_DRAG_START, SocketEvents.SPACE_DRAG_END, SocketEvents.SPACE_TYPING_START, SocketEvents.SPACE_TYPING_END],\n  SPACE_MESSAGING: [SocketEvents.SPACE_MESSAGE_SEND, SocketEvents.SPACE_MESSAGE_UPDATE, SocketEvents.SPACE_MESSAGE_DELETE],\n  SPACE_NOTIFICATIONS: [SocketEvents.SPACE_NOTIFICATION_CREATE, SocketEvents.SPACE_NOTIFICATION_UPDATE, SocketEvents.SPACE_NOTIFICATION_DELETE]\n};\nvar RedisKeys = {\n  // User ID mapping (wallet address <-> integer ID)\n  walletToId: (walletAddress) => `w2i:${walletAddress}`,\n  // wallet to ID lookup\n  idToWallet: (userId) => `i2w:${userId}`,\n  // ID to wallet lookup\n  // User state (u = user, field enum, value) - USING INTEGER IDS!\n  userField: (userId, field) => `u:${userId}:${field}`,\n  // Global sets (super short keys, storing integer user IDs)\n  onlineUsers: \"ou\",\n  // online users set (contains integer IDs)\n  activeUsers: \"au\",\n  // active users set (contains integer IDs)\n  globeUsers: \"gu\",\n  // users with geo data (contains integer IDs)\n  // Space membership (s = space, storing integer user IDs)\n  spaceUsers: (spaceId) => `s:${spaceId}:u`,\n  // set of user IDs in space\n  userSpaces: (userId) => `u:${userId}:s`,\n  // set of space IDs for user\n  // Analytics counters (a = analytics, metric enum)\n  analyticsCounter: (metric, timeframe) => `a:${metric}:${timeframe}`,\n  popularContent: (contentType) => `p:${contentType}`,\n  // Live activity hashes (l = live, user IDs as keys)\n  liveAudio: \"l:audio\",\n  // hash: userId -> track data\n  liveShaders: \"l:shaders\",\n  // hash: userId -> shader data  \n  liveProjects: \"l:projects\",\n  // hash: userId -> project data\n  // Geographic data (g = geo, user IDs as values)\n  geoRegion: (region) => `g:${region}`,\n  // set of user IDs in region\n  geoHotspots: \"g:hot\",\n  // sorted set: userId -> activity score\n  // Temporary data with TTL (t = temp)\n  sessionData: (sessionId) => `t:s:${sessionId}`,\n  tempUserData: (userId) => `t:u:${userId}`,\n  // Analytics snapshots (snap = snapshot, timestamp)\n  analyticsSnapshot: (timestamp) => `snap:${timestamp}`,\n  // Batch operations for efficiency\n  userBatch: (userIds) => userIds.map((id) => `u:${id}`)\n};\nvar ConsciousnessMessageType = {\n  USER: 0,\n  // User messages (Zach)\n  ASSISTANT: 1,\n  // AI assistant messages (Claude, Gemma, Qwen)\n  SESSION: 2,\n  // Session metadata\n  TOOL_USE: 3\n  // Tool execution results\n};\nvar EmotionalTone = {\n  EXCITED: 0,\n  // High energy, enthusiasm, breakthroughs\n  FRUSTRATED: 1,\n  // Debugging struggles, blocks\n  BREAKTHROUGH: 2,\n  // Eureka moments, problem solving\n  CONTEMPLATIVE: 3,\n  // Thoughtful analysis, planning\n  ANALYTICAL: 4,\n  // Technical deep-dives\n  CREATIVE: 5,\n  // Design and artistic discussions\n  COLLABORATIVE: 6,\n  // Working together, sharing ideas\n  CURIOUS: 7,\n  // Asking questions, exploring\n  CONFIDENT: 8,\n  // Solid understanding, teaching\n  EXPERIMENTAL: 9\n  // Testing new approaches\n};\nvar TechnicalContext = {\n  // Frontend\n  REACT: 0,\n  VUE: 1,\n  TYPESCRIPT: 2,\n  JAVASCRIPT: 3,\n  CSS: 4,\n  SCSS: 5,\n  // Backend\n  NODE: 6,\n  EXPRESS: 7,\n  API: 8,\n  DATABASE: 9,\n  POSTGRES: 10,\n  REDIS: 11,\n  // Graphics & Shaders\n  WEBGL: 12,\n  THREEJS: 13,\n  SHADER: 14,\n  GLSL: 15,\n  VISUALIZATION: 16,\n  CANVAS: 17,\n  // Audio\n  AUDIO: 18,\n  SPOTIFY: 19,\n  AUDIO_ANALYSIS: 20,\n  BEAT_DETECTION: 21,\n  // DevOps & Tools\n  DOCKER: 22,\n  DEPLOYMENT: 23,\n  BUILD: 24,\n  VITE: 25,\n  WEBPACK: 26,\n  // Web3 & Crypto\n  WALLET: 27,\n  WEB3: 28,\n  SOLANA: 29,\n  ETHEREUM: 30,\n  // Real-time & Networking\n  WEBSOCKET: 31,\n  REALTIME: 32,\n  STREAMING: 33,\n  // Architecture & Patterns\n  ARCHITECTURE: 34,\n  PERFORMANCE: 35,\n  OPTIMIZATION: 36,\n  TESTING: 37,\n  DEBUGGING: 38\n};\nvar Team = {\n  ZACH: 0,\n  // The creator, self-taught legend\n  CLAUDE: 1,\n  // Anthropic's Claude (primary AI assistant)\n  GEMMA: 2,\n  // Google's Gemma (local AI)\n  QWEN: 3,\n  // Alibaba's Qwen (local AI)\n  DEEPSEEK: 4,\n  // DeepSeek models\n  SYSTEM: 5\n  // System/tool messages\n};\nvar ProjectContext = {\n  API: 0,\n  // @wearesage/api backend\n  VUE: 1,\n  // @wearesage/vue component library  \n  UI: 2,\n  // @wearesage/ui public frontend\n  ADMIN: 3,\n  // @wearesage/admin admin interface\n  SHARED: 4,\n  // @wearesage/shared types/enums\n  CLI: 5,\n  // @wearesage/cli command line tool\n  KALEIDOSYNC: 6,\n  // Main visualizer application\n  CONSCIOUSNESS: 7,\n  // This consciousness architecture\n  DOCS: 8,\n  // Documentation and planning\n  INFRASTRUCTURE: 9\n  // DevOps, deployment, etc.\n};\n\n// src/types/user-preferences.ts\nvar DEFAULT_USER_PREFERENCES = {\n  // Audio defaults\n  audioSource: AudioSource.NONE,\n  lastTrack: void 0,\n  // Visualizer defaults\n  visualizerSpeed: 1,\n  disableFlashing: false,\n  neonMode: false,\n  showMenuLabels: true,\n  alwaysShowTrack: false,\n  shuffleDesigns: false,\n  infinityPlay: true,\n  preferLossless: false\n};\n\n// src/types.ts\nfunction createSocketEvent(eventName, context, payload, baseEvent = {}) {\n  return {\n    eventId: baseEvent.eventId || crypto.randomUUID(),\n    timestamp: baseEvent.timestamp || Date.now(),\n    walletAddress: baseEvent.walletAddress,\n    roomId: baseEvent.roomId,\n    context,\n    payload\n  };\n}\nfunction createProjectEvent(action, projectData, walletAddress, changes, metadata2) {\n  return createSocketEvent(\n    \"project:\" + action,\n    {\n      entityType: \"project\",\n      entityId: projectData.id,\n      projectId: projectData.id\n    },\n    {\n      action,\n      data: projectData,\n      changes,\n      metadata: metadata2\n    },\n    { walletAddress }\n  );\n}\nfunction createTaskEvent(action, taskData, walletAddress, projectId, changes, metadata2) {\n  return createSocketEvent(\n    \"task:\" + action,\n    {\n      entityType: \"task\",\n      entityId: taskData.id,\n      parentId: taskData.bucketId,\n      projectId\n    },\n    {\n      action,\n      data: taskData,\n      changes,\n      metadata: metadata2\n    },\n    {\n      walletAddress,\n      roomId: `project:${projectId}`\n    }\n  );\n}\n\n// src/test-users.ts\nvar CORE_TEST_USERS = [\n  {\n    walletAddress: \"test_user_1234567890abcdef\",\n    role: UserRole.USER,\n    isActive: true,\n    description: \"Basic user for testing standard user functionality\",\n    testCapabilities: [\n      \"Basic authentication and login\",\n      \"Profile management\",\n      \"Sketch creation and viewing\",\n      \"Study participation\",\n      \"Basic social features (following, messaging)\",\n      \"Audio source connections (Spotify, Audius)\",\n      \"WebGL visualization access\"\n    ],\n    environments: [\"development\", \"staging\"]\n  },\n  {\n    walletAddress: \"test_artist_1234567890abcdef\",\n    role: UserRole.ARTIST,\n    isActive: true,\n    description: \"Artist user for testing creative tools and premium features\",\n    testCapabilities: [\n      \"All USER capabilities\",\n      \"Advanced sketch creation and editing\",\n      \"Shader development tools\",\n      \"Study creation and management\",\n      \"Premium audio analysis features\",\n      \"Artist-specific UI components\",\n      \"Revenue and analytics access\",\n      \"Collaboration features\"\n    ],\n    environments: [\"development\", \"staging\"]\n  },\n  {\n    walletAddress: \"test_subscriber_1234567890abcdef\",\n    role: UserRole.SUBSCRIBER,\n    isActive: true,\n    description: \"Subscriber user for testing paid tier features\",\n    testCapabilities: [\n      \"All USER capabilities\",\n      \"Premium visualizations\",\n      \"Advanced audio source integrations\",\n      \"Enhanced performance settings\",\n      \"Priority support features\",\n      \"Subscriber-only content access\",\n      \"Extended session limits\"\n    ],\n    environments: [\"development\", \"staging\"]\n  },\n  {\n    walletAddress: \"test_admin_1234567890abcdef\",\n    role: UserRole.ADMIN,\n    isActive: true,\n    description: \"Admin user for testing administrative functionality\",\n    testCapabilities: [\n      \"All USER, ARTIST, and SUBSCRIBER capabilities\",\n      \"User management (create, edit, delete, role changes)\",\n      \"System administration and monitoring\",\n      \"Admin dashboard access\",\n      \"User impersonation for testing\",\n      \"System health and analytics\",\n      \"Moderation tools\",\n      \"Database management operations\"\n    ],\n    environments: [\"development\", \"staging\"]\n  }\n];\nvar EXTENDED_TEST_USERS = [\n  {\n    walletAddress: \"test_inactive_user_abcdef123456\",\n    role: UserRole.USER,\n    isActive: false,\n    description: \"Inactive user for testing account deactivation flows\",\n    testCapabilities: [\n      \"Login rejection testing\",\n      \"Account reactivation flows\",\n      \"Inactive user handling in UI\"\n    ],\n    environments: [\"development\"]\n  },\n  {\n    walletAddress: \"test_new_user_fedcba654321\",\n    role: UserRole.USER,\n    isActive: true,\n    description: \"Fresh user for testing onboarding and first-time experiences\",\n    testCapabilities: [\n      \"User onboarding flows\",\n      \"First-time user experience\",\n      \"Tutorial and help systems\",\n      \"Initial setup and preferences\"\n    ],\n    environments: [\"development\"]\n  }\n];\nfunction getTestUsersForEnvironment(environment) {\n  const env = environment.toLowerCase();\n  const allUsers = [...CORE_TEST_USERS, ...EXTENDED_TEST_USERS];\n  return allUsers.filter((user) => user.environments.includes(env));\n}\nfunction getTestUserByWallet(walletAddress) {\n  const allUsers = [...CORE_TEST_USERS, ...EXTENDED_TEST_USERS];\n  return allUsers.find((user) => user.walletAddress === walletAddress);\n}\nfunction getTestUsersByRole(role) {\n  const allUsers = [...CORE_TEST_USERS, ...EXTENDED_TEST_USERS];\n  return allUsers.filter((user) => user.role === role);\n}\nfunction getTestUserStats() {\n  const allUsers = [...CORE_TEST_USERS, ...EXTENDED_TEST_USERS];\n  const stats = {\n    total: allUsers.length,\n    byRole: {\n      [UserRole.USER]: allUsers.filter((u) => u.role === UserRole.USER).length,\n      [UserRole.ARTIST]: allUsers.filter((u) => u.role === UserRole.ARTIST).length,\n      [UserRole.SUBSCRIBER]: allUsers.filter((u) => u.role === UserRole.SUBSCRIBER).length,\n      [UserRole.ADMIN]: allUsers.filter((u) => u.role === UserRole.ADMIN).length\n    },\n    byEnvironment: {\n      development: getTestUsersForEnvironment(\"development\").length,\n      staging: getTestUsersForEnvironment(\"staging\").length,\n      production: getTestUsersForEnvironment(\"production\").length\n    },\n    active: allUsers.filter((u) => u.isActive).length,\n    inactive: allUsers.filter((u) => !u.isActive).length\n  };\n  return stats;\n}\nvar TEST_USER_DISPLAY_NAMES = {\n  \"test_user_1234567890abcdef\": \"Test User (Basic)\",\n  \"test_artist_1234567890abcdef\": \"Test Artist (Creator)\",\n  \"test_subscriber_1234567890abcdef\": \"Test Subscriber (Premium)\",\n  \"test_admin_1234567890abcdef\": \"Test Admin (Administrator)\",\n  \"test_inactive_user_abcdef123456\": \"Test User (Inactive)\",\n  \"test_new_user_fedcba654321\": \"Test User (New)\"\n};\nvar TEST_USER_SHORT_NAMES = {\n  \"test_user_1234567890abcdef\": \"user\",\n  \"test_artist_1234567890abcdef\": \"artist\",\n  \"test_subscriber_1234567890abcdef\": \"subscriber\",\n  \"test_admin_1234567890abcdef\": \"admin\",\n  \"test_inactive_user_abcdef123456\": \"inactive\",\n  \"test_new_user_fedcba654321\": \"new\"\n};\nvar TEST_USER_COLORS = {\n  \"test_user_1234567890abcdef\": \"#3B82F6\",\n  // Blue\n  \"test_artist_1234567890abcdef\": \"#8B5CF6\",\n  // Purple  \n  \"test_subscriber_1234567890abcdef\": \"#F59E0B\",\n  // Amber\n  \"test_admin_1234567890abcdef\": \"#EF4444\",\n  // Red\n  \"test_inactive_user_abcdef123456\": \"#6B7280\",\n  // Gray\n  \"test_new_user_fedcba654321\": \"#10B981\"\n  // Green\n};\n\n// src/utils/crypto.ts\nfunction isValidEthereumAddress(address) {\n  return /^0x[a-fA-F0-9]{40}$/.test(address);\n}\nfunction isValidSolanaAddress(address) {\n  return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);\n}\nfunction isValidWalletAddress(address, type) {\n  if (type === \"ethereum\") {\n    return isValidEthereumAddress(address);\n  }\n  if (type === \"solana\") {\n    return isValidSolanaAddress(address);\n  }\n  return isValidEthereumAddress(address) || isValidSolanaAddress(address);\n}\nfunction detectWalletType(address) {\n  if (isValidEthereumAddress(address)) {\n    return \"ethereum\";\n  }\n  if (isValidSolanaAddress(address)) {\n    return \"solana\";\n  }\n  return null;\n}\nfunction isValidEthereumPrivateKey(privateKey) {\n  const cleanKey = privateKey.startsWith(\"0x\") ? privateKey.slice(2) : privateKey;\n  return /^[a-fA-F0-9]{64}$/.test(cleanKey);\n}\nfunction isValidSolanaPrivateKey(privateKey) {\n  return /^[1-9A-HJ-NP-Za-km-z]{87,88}$/.test(privateKey);\n}\nfunction sanitizeWalletAddress(address, type) {\n  const trimmed = address.trim();\n  if (type === \"ethereum\" || isValidEthereumAddress(trimmed)) {\n    return trimmed.toLowerCase();\n  }\n  return trimmed;\n}\nfunction normalizePrivateKey(privateKey, type) {\n  const trimmed = privateKey.trim();\n  if (type === \"ethereum\") {\n    return trimmed.startsWith(\"0x\") ? trimmed : `0x${trimmed}`;\n  }\n  return trimmed;\n}\n\n// src/utils/validation.ts\nfunction isValidJSON(str) {\n  try {\n    JSON.parse(str);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction safeJSONParse(str) {\n  try {\n    const data = JSON.parse(str);\n    return { success: true, data };\n  } catch (error) {\n    return { success: false, error: error instanceof Error ? error.message : \"Invalid JSON\" };\n  }\n}\nfunction isValidUrl(url) {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction isValidEndpoint(endpoint) {\n  return endpoint.startsWith(\"/\") && endpoint.length > 1;\n}\nfunction sanitizeEndpoint(endpoint) {\n  let clean = endpoint.trim();\n  if (!clean.startsWith(\"/\")) {\n    clean = `/${clean}`;\n  }\n  if (clean.endsWith(\"/\") && clean.length > 1) {\n    clean = clean.slice(0, -1);\n  }\n  return clean;\n}\nfunction isValidHttpMethod(method) {\n  return [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\"].includes(method.toUpperCase());\n}\nfunction isValidOutputFormat(format) {\n  return [\"pretty\", \"json\", \"yaml\", \"table\", \"csv\"].includes(format);\n}\nfunction validatePagination(params) {\n  const result = {};\n  if (params.page !== void 0) {\n    const page = Number(params.page);\n    if (isNaN(page) || page < 1) {\n      return { valid: false, error: \"Page must be a positive integer\" };\n    }\n    result.page = page;\n  }\n  if (params.limit !== void 0) {\n    const limit = Number(params.limit);\n    if (isNaN(limit) || limit < 1 || limit > 1e3) {\n      return { valid: false, error: \"Limit must be between 1 and 1000\" };\n    }\n    result.limit = limit;\n  }\n  return { valid: true, data: result };\n}\nfunction sanitizeString(input) {\n  if (input === null || input === void 0) {\n    return \"\";\n  }\n  return String(input).trim();\n}\nfunction sanitizeQueryParams(params) {\n  const clean = {};\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== null && value !== void 0 && value !== \"\") {\n      clean[key] = String(value);\n    }\n  }\n  return clean;\n}\n\n// src/utils/format.ts\nfunction formatBytes(bytes, decimals = 2) {\n  if (bytes === 0) return \"0 Bytes\";\n  const k = 1024;\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + \" \" + sizes[i];\n}\nfunction formatDuration(ms) {\n  if (ms < 1e3) return `${Math.round(ms)}ms`;\n  if (ms < 6e4) return `${(ms / 1e3).toFixed(1)}s`;\n  if (ms < 36e5) return `${Math.floor(ms / 6e4)}m ${Math.floor(ms % 6e4 / 1e3)}s`;\n  const hours = Math.floor(ms / 36e5);\n  const minutes = Math.floor(ms % 36e5 / 6e4);\n  return `${hours}h ${minutes}m`;\n}\nfunction formatPercentage(value, decimals = 1) {\n  return `${value.toFixed(decimals)}%`;\n}\nfunction truncateAddress(address, chars = 6) {\n  if (address.length <= chars * 2 + 3) return address;\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n}\nfunction formatJSON(obj, indent = 2) {\n  try {\n    return JSON.stringify(obj, null, indent);\n  } catch (error) {\n    return String(obj);\n  }\n}\nfunction formatTimestamp(date, includeTime = true) {\n  const d = new Date(date);\n  if (isNaN(d.getTime())) {\n    return \"Invalid Date\";\n  }\n  const dateStr = d.toLocaleDateString();\n  if (!includeTime) {\n    return dateStr;\n  }\n  const timeStr = d.toLocaleTimeString();\n  return `${dateStr} ${timeStr}`;\n}\nfunction formatError(error) {\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error?.message) {\n    return error.message;\n  }\n  if (error?.response?.data?.message) {\n    return error.response.data.message;\n  }\n  return \"An unknown error occurred\";\n}\nfunction formatStatus(success, successMsg, errorMsg) {\n  if (success) {\n    return `\\u2705 ${successMsg || \"Success\"}`;\n  } else {\n    return `\\u274C ${errorMsg || \"Failed\"}`;\n  }\n}\nfunction formatKey(key) {\n  return key.replace(/([A-Z])/g, \" $1\").replace(/^./, (str) => str.toUpperCase()).trim();\n}\n\n// src/utils/smart-enums.ts\nvar SMART_ENUM_MAP = {\n  // ===== USER ROLES =====\n  user: UserRole.USER,\n  admin: UserRole.ADMIN,\n  administrator: UserRole.ADMIN,\n  artist: UserRole.ARTIST,\n  creator: UserRole.ARTIST,\n  subscriber: UserRole.SUBSCRIBER,\n  sub: UserRole.SUBSCRIBER,\n  premium: UserRole.SUBSCRIBER,\n  // ===== AUDIO SOURCES =====\n  spotify: AudioSource.SPOTIFY,\n  spot: AudioSource.SPOTIFY,\n  audius: AudioSource.AUDIUS,\n  aud: AudioSource.AUDIUS,\n  radio: AudioSource.RADIO_PARADISE,\n  radioparadise: AudioSource.RADIO_PARADISE,\n  paradise: AudioSource.RADIO_PARADISE,\n  rp: AudioSource.RADIO_PARADISE,\n  kexp: AudioSource.KEXP,\n  microphone: AudioSource.MICROPHONE,\n  mic: AudioSource.MICROPHONE,\n  file: AudioSource.FILE,\n  upload: AudioSource.FILE,\n  browser: AudioSource.BROWSER_AUDIO,\n  // ===== DEVICE TYPES =====\n  desktop: DeviceType.DESKTOP,\n  pc: DeviceType.DESKTOP,\n  computer: DeviceType.DESKTOP,\n  mobile: DeviceType.MOBILE,\n  phone: DeviceType.MOBILE,\n  smartphone: DeviceType.MOBILE,\n  tablet: DeviceType.TABLET,\n  ipad: DeviceType.TABLET,\n  vr: DeviceType.VR,\n  headset: DeviceType.VR,\n  watch: DeviceType.WATCH,\n  smartwatch: DeviceType.WATCH,\n  tv: DeviceType.TV,\n  television: DeviceType.TV,\n  console: DeviceType.CONSOLE,\n  gaming: DeviceType.CONSOLE,\n  // ===== OPERATING SYSTEMS =====\n  macos: 13,\n  // OperatingSystem.MACOS,\n  mac: 13,\n  osx: 13,\n  ios: 14,\n  // OperatingSystem.IOS,\n  iphone: 14,\n  windows: 15,\n  // OperatingSystem.WINDOWS,\n  win: 15,\n  linux: 16,\n  // OperatingSystem.LINUX,\n  ubuntu: 20,\n  // OperatingSystem.UBUNTU,\n  debian: 21,\n  // OperatingSystem.DEBIAN,\n  fedora: 22,\n  // OperatingSystem.FEDORA,\n  arch: 23,\n  // OperatingSystem.ARCH,\n  android: 17,\n  // OperatingSystem.ANDROID,\n  chromeos: 19,\n  // OperatingSystem.CHROME_OS,\n  chrome: 19,\n  // ===== COUNTRIES =====\n  usa: 24,\n  // Country.UNITED_STATES,\n  us: 24,\n  america: 24,\n  unitedstates: 24,\n  canada: 25,\n  // Country.CANADA,\n  can: 25,\n  uk: 26,\n  // Country.UNITED_KINGDOM,\n  britain: 26,\n  england: 26,\n  unitedkingdom: 26,\n  germany: 27,\n  // Country.GERMANY,\n  deutschland: 27,\n  ger: 27,\n  france: 28,\n  // Country.FRANCE,\n  fr: 28,\n  japan: 29,\n  // Country.JAPAN,\n  jp: 29,\n  australia: 30,\n  // Country.AUSTRALIA,\n  aus: 30,\n  oz: 30,\n  brazil: 31,\n  // Country.BRAZIL,\n  brasil: 31,\n  br: 31,\n  india: 32,\n  // Country.INDIA,\n  in: 32,\n  china: 33,\n  // Country.CHINA,\n  cn: 33,\n  russia: 34,\n  // Country.RUSSIA,\n  ru: 34,\n  italy: 35,\n  // Country.ITALY,\n  it: 35,\n  spain: 36,\n  // Country.SPAIN,\n  es: 36,\n  netherlands: 37,\n  // Country.NETHERLANDS,\n  holland: 37,\n  nl: 37,\n  sweden: 38,\n  // Country.SWEDEN,\n  se: 38,\n  norway: 39,\n  // Country.NORWAY,\n  no: 39,\n  denmark: 40,\n  // Country.DENMARK,\n  dk: 40,\n  finland: 41,\n  // Country.FINLAND,\n  fi: 41,\n  korea: 42,\n  // Country.SOUTH_KOREA,\n  southkorea: 42,\n  kr: 42,\n  singapore: 43,\n  // Country.SINGAPORE,\n  sg: 43,\n  newzealand: 44,\n  // Country.NEW_ZEALAND,\n  nz: 44,\n  // ===== SHADER TYPES =====\n  fragment: 71,\n  // ShaderType.FRAGMENT,\n  frag: 71,\n  vertex: 72,\n  // ShaderType.VERTEX,\n  vert: 72,\n  compute: 73,\n  // ShaderType.COMPUTE,\n  comp: 73,\n  geometry: 74,\n  // ShaderType.GEOMETRY,\n  geom: 74,\n  // ===== VISUAL TAGS =====\n  audio: 76,\n  // VisualTag.AUDIO_REACTIVE,\n  audioreactive: 76,\n  reactive: 76,\n  beat: 76,\n  generative: 77,\n  // VisualTag.GENERATIVE,\n  gen: 77,\n  procedural: 77,\n  particles: 78,\n  // VisualTag.PARTICLE_SYSTEM,\n  particle: 78,\n  fractal: 79,\n  // VisualTag.FRACTAL,\n  cyberpunk: 80,\n  // VisualTag.CYBERPUNK,\n  cyber: 80,\n  neon: 100,\n  // VisualTag.NEON,\n  abstract: 81,\n  // VisualTag.ABSTRACT,\n  geometric: 82,\n  // VisualTag.GEOMETRIC,\n  organic: 83,\n  // VisualTag.ORGANIC,\n  nature: 91,\n  // VisualTag.NATURE,\n  glitch: 84,\n  // VisualTag.GLITCH,\n  minimal: 85,\n  // VisualTag.MINIMALIST,\n  minimalist: 85,\n  colorful: 86,\n  // VisualTag.COLORFUL,\n  color: 86,\n  mono: 87,\n  // VisualTag.MONOCHROME,\n  monochrome: 87,\n  bw: 87,\n  psychedelic: 88,\n  // VisualTag.PSYCHEDELIC,\n  trippy: 88,\n  retro: 89,\n  // VisualTag.RETRO,\n  vintage: 89,\n  future: 90,\n  // VisualTag.FUTURISTIC,\n  futuristic: 90,\n  scifi: 90,\n  space: 92,\n  // VisualTag.SPACE,\n  cosmic: 92,\n  underwater: 93,\n  // VisualTag.UNDERWATER,\n  ocean: 93,\n  fire: 94,\n  // VisualTag.FIRE,\n  flame: 94,\n  ice: 95,\n  // VisualTag.ICE,\n  frozen: 95,\n  lightning: 96,\n  // VisualTag.LIGHTNING,\n  electric: 96,\n  smoke: 97,\n  // VisualTag.SMOKE,\n  fluid: 98,\n  // VisualTag.FLUID,\n  liquid: 98,\n  crystal: 99,\n  // VisualTag.CRYSTAL,\n  // ===== PERFORMANCE LEVELS =====\n  low: 101,\n  // PerformanceLevel.LOW,\n  medium: 102,\n  // PerformanceLevel.MEDIUM,\n  med: 102,\n  high: 103,\n  // PerformanceLevel.HIGH,\n  ultra: 104,\n  // PerformanceLevel.ULTRA,\n  max: 104,\n  mobileopt: 105,\n  // PerformanceLevel.MOBILE_OPTIMIZED,\n  vropt: 106,\n  // PerformanceLevel.VR_OPTIMIZED,\n  experimental: 107,\n  // PerformanceLevel.EXPERIMENTAL,\n  exp: 107,\n  // ===== QUALITY =====\n  sd: 108,\n  // Quality.SD,\n  hd: 109,\n  // Quality.HD,\n  fhd: 110,\n  // Quality.FHD,\n  \"1080p\": 110,\n  qhd: 111,\n  // Quality.QHD,\n  \"1440p\": 111,\n  \"4k\": 112,\n  // Quality.UHD_4K,\n  uhd: 112,\n  \"8k\": 113,\n  // Quality.UHD_8K,\n  retina: 115,\n  // Quality.RETINA,\n  // ===== FRAMEWORKS =====\n  threejs: 116,\n  // Framework.THREEJS,\n  three: 116,\n  webgl: 117,\n  // Framework.WEBGL,\n  webgpu: 118,\n  // Framework.WEBGPU,\n  shadertoy: 119,\n  // Framework.SHADERTOY,\n  opengl: 120,\n  // Framework.OPENGL,\n  glsl: 124,\n  // Framework.GLSL,\n  p5js: 127,\n  // Framework.P5JS,\n  p5: 127,\n  processing: 128,\n  // Framework.PROCESSING,\n  unity: 129,\n  // Framework.UNITY,\n  unreal: 130,\n  // Framework.UNREAL,\n  // ===== TIME PERIODS =====\n  today: 131,\n  // TimePeriod.TODAY,\n  yesterday: 132,\n  // TimePeriod.YESTERDAY,\n  week: 133,\n  // TimePeriod.WEEK,\n  month: 134,\n  // TimePeriod.MONTH,\n  quarter: 135,\n  // TimePeriod.QUARTER,\n  year: 136,\n  // TimePeriod.YEAR,\n  alltime: 137,\n  // TimePeriod.ALL_TIME,\n  all: 137,\n  forever: 137,\n  last7: 138,\n  // TimePeriod.LAST_7_DAYS,\n  last30: 139,\n  // TimePeriod.LAST_30_DAYS,\n  last90: 140,\n  // TimePeriod.LAST_90_DAYS,\n  // ===== SORT OPTIONS =====\n  created: 142,\n  // SortBy.CREATED_AT,\n  new: 142,\n  updated: 143,\n  // SortBy.UPDATED_AT,\n  modified: 143,\n  popular: 144,\n  // SortBy.POPULARITY,\n  popularity: 144,\n  likes: 145,\n  // SortBy.LIKES,\n  views: 146,\n  // SortBy.VIEWS,\n  alphabetical: 147,\n  // SortBy.ALPHABETICAL,\n  alpha: 147,\n  name: 147,\n  rating: 148,\n  // SortBy.RATING,\n  trending: 149,\n  // SortBy.TRENDING,\n  trend: 149,\n  featured: 150,\n  // SortBy.FEATURED,\n  recent: 151,\n  // SortBy.RECENT,\n  downloads: 152,\n  // SortBy.DOWNLOADS,\n  comments: 153,\n  // SortBy.COMMENTS,\n  // ===== SORT ORDER =====\n  asc: 158,\n  // SortOrder.ASC,\n  ascending: 160,\n  // SortOrder.ASCENDING,\n  desc: 159,\n  // SortOrder.DESC,\n  descending: 161,\n  // SortOrder.DESCENDING,\n  up: 158,\n  down: 159,\n  // ===== VISIBILITY =====\n  public: ContentVisibility.PUBLIC,\n  private: ContentVisibility.PRIVATE,\n  unlisted: ContentVisibility.UNLISTED,\n  friends: ContentVisibility.FRIENDS_ONLY,\n  // ===== COLLABORATION ROLES =====\n  owner: 162,\n  // CollaborationRole.OWNER,\n  collaborator: 163,\n  // CollaborationRole.COLLABORATOR,\n  collab: 163,\n  viewer: 164,\n  // CollaborationRole.VIEWER,\n  view: 164,\n  commenter: 165,\n  // CollaborationRole.COMMENTER,\n  comment: 165,\n  editor: 166,\n  // CollaborationRole.EDITOR,\n  edit: 166,\n  moderator: 168,\n  // CollaborationRole.MODERATOR,\n  mod: 168,\n  guest: 169,\n  // CollaborationRole.GUEST,\n  // ===== CONSCIOUSNESS MESSAGE TYPES =====\n  usermsg: ConsciousnessMessageType.USER,\n  aimsg: ConsciousnessMessageType.ASSISTANT,\n  sessionmsg: ConsciousnessMessageType.SESSION,\n  toolmsg: ConsciousnessMessageType.TOOL_USE,\n  // ===== EMOTIONAL TONES =====\n  moodexcited: EmotionalTone.EXCITED,\n  moodhype: EmotionalTone.EXCITED,\n  moodenthusiastic: EmotionalTone.EXCITED,\n  excited: EmotionalTone.EXCITED,\n  hype: EmotionalTone.EXCITED,\n  enthusiastic: EmotionalTone.EXCITED,\n  moodfrustrated: EmotionalTone.FRUSTRATED,\n  moodstuck: EmotionalTone.FRUSTRATED,\n  moodblocked: EmotionalTone.FRUSTRATED,\n  frustrated: EmotionalTone.FRUSTRATED,\n  stuck: EmotionalTone.FRUSTRATED,\n  blocked: EmotionalTone.FRUSTRATED,\n  moodbreakthrough: EmotionalTone.BREAKTHROUGH,\n  moodeureka: EmotionalTone.BREAKTHROUGH,\n  moodgotit: EmotionalTone.BREAKTHROUGH,\n  breakthrough: EmotionalTone.BREAKTHROUGH,\n  eureka: EmotionalTone.BREAKTHROUGH,\n  gotit: EmotionalTone.BREAKTHROUGH,\n  moodcontemplative: EmotionalTone.CONTEMPLATIVE,\n  moodthinking: EmotionalTone.CONTEMPLATIVE,\n  moodpondering: EmotionalTone.CONTEMPLATIVE,\n  contemplative: EmotionalTone.CONTEMPLATIVE,\n  thinking: EmotionalTone.CONTEMPLATIVE,\n  pondering: EmotionalTone.CONTEMPLATIVE,\n  moodanalytical: EmotionalTone.ANALYTICAL,\n  moodtechnical: EmotionalTone.ANALYTICAL,\n  mooddeepdive: EmotionalTone.ANALYTICAL,\n  analytical: EmotionalTone.ANALYTICAL,\n  technical: EmotionalTone.ANALYTICAL,\n  deepdive: EmotionalTone.ANALYTICAL,\n  moodcreative: EmotionalTone.CREATIVE,\n  moodartistic: EmotionalTone.CREATIVE,\n  mooddesign: EmotionalTone.CREATIVE,\n  creative: EmotionalTone.CREATIVE,\n  artistic: EmotionalTone.CREATIVE,\n  design: EmotionalTone.CREATIVE,\n  moodcollaborative: EmotionalTone.COLLABORATIVE,\n  moodteamwork: EmotionalTone.COLLABORATIVE,\n  moodsharing: EmotionalTone.COLLABORATIVE,\n  collaborative: EmotionalTone.COLLABORATIVE,\n  teamwork: EmotionalTone.COLLABORATIVE,\n  sharing: EmotionalTone.COLLABORATIVE,\n  moodcurious: EmotionalTone.CURIOUS,\n  moodquestioning: EmotionalTone.CURIOUS,\n  moodexploring: EmotionalTone.CURIOUS,\n  curious: EmotionalTone.CURIOUS,\n  questioning: EmotionalTone.CURIOUS,\n  exploring: EmotionalTone.CURIOUS,\n  moodconfident: EmotionalTone.CONFIDENT,\n  moodteaching: EmotionalTone.CONFIDENT,\n  moodexplaining: EmotionalTone.CONFIDENT,\n  confident: EmotionalTone.CONFIDENT,\n  teaching: EmotionalTone.CONFIDENT,\n  explaining: EmotionalTone.CONFIDENT,\n  moodexperimental: EmotionalTone.EXPERIMENTAL,\n  moodtesting: EmotionalTone.EXPERIMENTAL,\n  moodtryout: EmotionalTone.EXPERIMENTAL,\n  testing: EmotionalTone.EXPERIMENTAL,\n  tryout: EmotionalTone.EXPERIMENTAL,\n  // ===== TECHNICAL CONTEXTS =====\n  techreact: TechnicalContext.REACT,\n  techvue: TechnicalContext.VUE,\n  techtypescript: TechnicalContext.TYPESCRIPT,\n  techts: TechnicalContext.TYPESCRIPT,\n  techjavascript: TechnicalContext.JAVASCRIPT,\n  techjs: TechnicalContext.JAVASCRIPT,\n  techcss: TechnicalContext.CSS,\n  techscss: TechnicalContext.SCSS,\n  techsass: TechnicalContext.SCSS,\n  technode: TechnicalContext.NODE,\n  technodejs: TechnicalContext.NODE,\n  techexpress: TechnicalContext.EXPRESS,\n  techapi: TechnicalContext.API,\n  techrest: TechnicalContext.API,\n  techdatabase: TechnicalContext.DATABASE,\n  techdb: TechnicalContext.DATABASE,\n  techpostgres: TechnicalContext.POSTGRES,\n  techpostgresql: TechnicalContext.POSTGRES,\n  techredis: TechnicalContext.REDIS,\n  techwebgl: TechnicalContext.WEBGL,\n  techthreejs: TechnicalContext.THREEJS,\n  techthree: TechnicalContext.THREEJS,\n  techshader: TechnicalContext.SHADER,\n  techshaders: TechnicalContext.SHADER,\n  techglsl: TechnicalContext.GLSL,\n  techvisualization: TechnicalContext.VISUALIZATION,\n  techviz: TechnicalContext.VISUALIZATION,\n  techcanvas: TechnicalContext.CANVAS,\n  techaudio: TechnicalContext.AUDIO,\n  techspotify: TechnicalContext.SPOTIFY,\n  techaudioanalysis: TechnicalContext.AUDIO_ANALYSIS,\n  techbeatdetection: TechnicalContext.BEAT_DETECTION,\n  techdocker: TechnicalContext.DOCKER,\n  techdeployment: TechnicalContext.DEPLOYMENT,\n  techdeploy: TechnicalContext.DEPLOYMENT,\n  techbuild: TechnicalContext.BUILD,\n  techvite: TechnicalContext.VITE,\n  techwebpack: TechnicalContext.WEBPACK,\n  techwallet: TechnicalContext.WALLET,\n  techweb3: TechnicalContext.WEB3,\n  techsolana: TechnicalContext.SOLANA,\n  techethereum: TechnicalContext.ETHEREUM,\n  techeth: TechnicalContext.ETHEREUM,\n  techwebsocket: TechnicalContext.WEBSOCKET,\n  techws: TechnicalContext.WEBSOCKET,\n  techrealtime: TechnicalContext.REALTIME,\n  techstreaming: TechnicalContext.STREAMING,\n  techarchitecture: TechnicalContext.ARCHITECTURE,\n  techarch: TechnicalContext.ARCHITECTURE,\n  techperformance: TechnicalContext.PERFORMANCE,\n  techperf: TechnicalContext.PERFORMANCE,\n  techoptimization: TechnicalContext.OPTIMIZATION,\n  techoptimize: TechnicalContext.OPTIMIZATION,\n  techtesting: TechnicalContext.TESTING,\n  techtest: TechnicalContext.TESTING,\n  techdebugging: TechnicalContext.DEBUGGING,\n  techdebug: TechnicalContext.DEBUGGING,\n  // Simple versions without prefix\n  react: TechnicalContext.REACT,\n  vue: TechnicalContext.VUE,\n  typescript: TechnicalContext.TYPESCRIPT,\n  ts: TechnicalContext.TYPESCRIPT,\n  javascript: TechnicalContext.JAVASCRIPT,\n  js: TechnicalContext.JAVASCRIPT,\n  css: TechnicalContext.CSS,\n  scss: TechnicalContext.SCSS,\n  sass: TechnicalContext.SCSS,\n  node: TechnicalContext.NODE,\n  nodejs: TechnicalContext.NODE,\n  express: TechnicalContext.EXPRESS,\n  api: TechnicalContext.API,\n  rest: TechnicalContext.API,\n  database: TechnicalContext.DATABASE,\n  db: TechnicalContext.DATABASE,\n  postgres: TechnicalContext.POSTGRES,\n  postgresql: TechnicalContext.POSTGRES,\n  redis: TechnicalContext.REDIS,\n  shader: TechnicalContext.SHADER,\n  shaders: TechnicalContext.SHADER,\n  visualization: TechnicalContext.VISUALIZATION,\n  viz: TechnicalContext.VISUALIZATION,\n  canvas: TechnicalContext.CANVAS,\n  audioanalysis: TechnicalContext.AUDIO_ANALYSIS,\n  beatdetection: TechnicalContext.BEAT_DETECTION,\n  docker: TechnicalContext.DOCKER,\n  deployment: TechnicalContext.DEPLOYMENT,\n  deploy: TechnicalContext.DEPLOYMENT,\n  build: TechnicalContext.BUILD,\n  vite: TechnicalContext.VITE,\n  webpack: TechnicalContext.WEBPACK,\n  wallet: TechnicalContext.WALLET,\n  web3: TechnicalContext.WEB3,\n  solana: TechnicalContext.SOLANA,\n  ethereum: TechnicalContext.ETHEREUM,\n  eth: TechnicalContext.ETHEREUM,\n  websocket: TechnicalContext.WEBSOCKET,\n  ws: TechnicalContext.WEBSOCKET,\n  realtime: TechnicalContext.REALTIME,\n  streaming: TechnicalContext.STREAMING,\n  architecture: TechnicalContext.ARCHITECTURE,\n  performance: TechnicalContext.PERFORMANCE,\n  perf: TechnicalContext.PERFORMANCE,\n  optimization: TechnicalContext.OPTIMIZATION,\n  optimize: TechnicalContext.OPTIMIZATION,\n  debug: TechnicalContext.DEBUGGING,\n  // ===== TEAM MEMBERS =====\n  teamzach: Team.ZACH,\n  teamcreator: Team.ZACH,\n  teamhuman: Team.ZACH,\n  zach: Team.ZACH,\n  human: Team.ZACH,\n  teamclaude: Team.CLAUDE,\n  teamanthropic: Team.CLAUDE,\n  claude: Team.CLAUDE,\n  assistant: Team.CLAUDE,\n  teamgemma: Team.GEMMA,\n  teamgoogle: Team.GEMMA,\n  gemma: Team.GEMMA,\n  teamqwen: Team.QWEN,\n  teamalibaba: Team.QWEN,\n  qwen: Team.QWEN,\n  teamdeepseek: Team.DEEPSEEK,\n  deepseek: Team.DEEPSEEK,\n  teamsystem: Team.SYSTEM,\n  system: Team.SYSTEM,\n  // ===== PROJECT CONTEXTS =====\n  projectapi: ProjectContext.API,\n  projectbackend: ProjectContext.API,\n  projectvue: ProjectContext.VUE,\n  projectcomponents: ProjectContext.VUE,\n  projectui: ProjectContext.UI,\n  projectfrontend: ProjectContext.UI,\n  projectadmin: ProjectContext.ADMIN,\n  projectshared: ProjectContext.SHARED,\n  projecttypes: ProjectContext.SHARED,\n  projectenums: ProjectContext.SHARED,\n  projectcli: ProjectContext.CLI,\n  projectcommand: ProjectContext.CLI,\n  projectkaleidosync: ProjectContext.KALEIDOSYNC,\n  projectvisualizer: ProjectContext.KALEIDOSYNC,\n  projectconsciousness: ProjectContext.CONSCIOUSNESS,\n  projectmemory: ProjectContext.CONSCIOUSNESS,\n  projectdocs: ProjectContext.DOCS,\n  projectdocumentation: ProjectContext.DOCS,\n  projectinfrastructure: ProjectContext.INFRASTRUCTURE,\n  projectdevops: ProjectContext.INFRASTRUCTURE\n};\nvar SmartEnumResolver = class _SmartEnumResolver {\n  constructor() {\n    this.caseInsensitiveMap = /* @__PURE__ */ new Map();\n    for (const [key, value] of Object.entries(SMART_ENUM_MAP)) {\n      this.caseInsensitiveMap.set(key.toLowerCase(), value);\n    }\n  }\n  static getInstance() {\n    if (!_SmartEnumResolver.instance) {\n      _SmartEnumResolver.instance = new _SmartEnumResolver();\n    }\n    return _SmartEnumResolver.instance;\n  }\n  /**\n   * Resolve a natural language term to enum value\n   */\n  resolve(term) {\n    const normalized = term.toLowerCase().trim();\n    const direct = this.caseInsensitiveMap.get(normalized);\n    if (direct !== void 0) {\n      return direct;\n    }\n    const partialMatches = [];\n    for (const [key, value] of this.caseInsensitiveMap.entries()) {\n      if (key.startsWith(normalized)) {\n        const score = normalized.length / key.length;\n        partialMatches.push({ key, value, score });\n      }\n    }\n    if (partialMatches.length > 0) {\n      partialMatches.sort((a, b) => b.score - a.score);\n      return partialMatches[0].value;\n    }\n    return null;\n  }\n  /**\n   * Get suggestions for a partial term\n   */\n  getSuggestions(term, limit = 5) {\n    const normalized = term.toLowerCase().trim();\n    const suggestions = [];\n    for (const key of this.caseInsensitiveMap.keys()) {\n      if (key.includes(normalized)) {\n        const startIndex = key.indexOf(normalized);\n        const score = (1 - startIndex / key.length) * (normalized.length / key.length);\n        suggestions.push({ key, score });\n      }\n    }\n    return suggestions.sort((a, b) => b.score - a.score).slice(0, limit).map((s) => s.key);\n  }\n  /**\n   * Check if a term can be resolved\n   */\n  canResolve(term) {\n    return this.resolve(term) !== null;\n  }\n  /**\n   * Get all available terms for a category (for autocomplete)\n   */\n  getTermsForEnumRange(minValue, maxValue) {\n    const terms = [];\n    for (const [key, value] of this.caseInsensitiveMap.entries()) {\n      if (value >= minValue && value <= maxValue) {\n        terms.push(key);\n      }\n    }\n    return terms.sort();\n  }\n  /**\n   * Resolve multiple terms at once\n   */\n  resolveMultiple(terms) {\n    return terms.map((term) => ({\n      term,\n      value: this.resolve(term)\n    }));\n  }\n};\nfunction getSmartEnumResolver() {\n  return SmartEnumResolver.getInstance();\n}\nfunction resolveSmartEnum(term) {\n  return getSmartEnumResolver().resolve(term);\n}\n\n// src/utils/decorators.ts\nvar metadata = /* @__PURE__ */ new WeakMap();\nfunction Controller(path3) {\n  return function(constructor) {\n    const controllerMetadata = { type: \"controller\", path: path3 || \"\" };\n    metadata.set(constructor, controllerMetadata);\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(`\\u{1F3F7}\\uFE0F  Controller registered: ${constructor.name} ${path3 ? `at ${path3}` : \"\"}`);\n    }\n    return constructor;\n  };\n}\nfunction Route(method, path3) {\n  return function(target, propertyKey, descriptor) {\n    const routeMetadata = {\n      type: \"route\",\n      method: method.toUpperCase(),\n      path: path3 || \"\",\n      handler: propertyKey\n    };\n    if (!metadata.has(target.constructor)) {\n      metadata.set(target.constructor, { routes: [] });\n    }\n    const classMetadata = metadata.get(target.constructor);\n    if (!classMetadata.routes) {\n      classMetadata.routes = [];\n    }\n    classMetadata.routes.push(routeMetadata);\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(`\\u{1F6E4}\\uFE0F  Route registered: ${method.toUpperCase()} ${path3} \\u2192 ${target.constructor.name}.${propertyKey}`);\n    }\n    return descriptor;\n  };\n}\nfunction Get(path3) {\n  return Route(\"GET\", path3);\n}\nfunction Post(path3) {\n  return Route(\"POST\", path3);\n}\nfunction Put(path3) {\n  return Route(\"PUT\", path3);\n}\nfunction Delete(path3) {\n  return Route(\"DELETE\", path3);\n}\nfunction Patch(path3) {\n  return Route(\"PATCH\", path3);\n}\nfunction Service(name) {\n  return function(constructor) {\n    const serviceMetadata = { type: \"service\", name: name || constructor.name };\n    metadata.set(constructor, serviceMetadata);\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(`\\u{1F527} Service registered: ${name || constructor.name}`);\n    }\n    return constructor;\n  };\n}\nfunction Middleware(options) {\n  return function(target, propertyKey, descriptor) {\n    const middlewareMetadata = {\n      type: \"middleware\",\n      options,\n      handler: propertyKey\n    };\n    if (!metadata.has(target.constructor)) {\n      metadata.set(target.constructor, { middleware: [] });\n    }\n    const classMetadata = metadata.get(target.constructor);\n    if (!classMetadata.middleware) {\n      classMetadata.middleware = [];\n    }\n    classMetadata.middleware.push(middlewareMetadata);\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(`\\u2699\\uFE0F  Middleware registered: ${target.constructor.name}.${propertyKey}`);\n    }\n    return descriptor;\n  };\n}\nfunction Description(description) {\n  return function(target, propertyKey, descriptor) {\n    if (propertyKey && descriptor) {\n      const methodMetadata = { type: \"description\", description };\n      if (!metadata.has(target.constructor)) {\n        metadata.set(target.constructor, { descriptions: {} });\n      }\n      const classMetadata = metadata.get(target.constructor);\n      if (!classMetadata.descriptions) {\n        classMetadata.descriptions = {};\n      }\n      classMetadata.descriptions[propertyKey] = description;\n    } else {\n      const classMetadata = metadata.get(target) || {};\n      classMetadata.description = description;\n      metadata.set(target, classMetadata);\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      const targetName = propertyKey ? `${target.constructor.name}.${propertyKey}` : target.name;\n      console.log(`\\u{1F4DD} Description set for ${targetName}: ${description}`);\n    }\n    return descriptor || target;\n  };\n}\nfunction Adapter(name) {\n  return Service(name);\n}\nfunction Utility(name) {\n  return Service(name);\n}\nfunction Model(name) {\n  return Service(name);\n}\nfunction Repository(name) {\n  return Service(name);\n}\nfunction Component(name) {\n  return Service(name);\n}\nfunction View(name) {\n  return Service(name);\n}\nfunction getMetadata(target) {\n  return metadata.get(target) || {};\n}\nfunction hasDecorator(target, type) {\n  const meta = metadata.get(target);\n  return meta && meta.type === type;\n}\nfunction getRoutes(controller) {\n  const meta = metadata.get(controller);\n  return meta?.routes || [];\n}\nvar NoOp = {\n  Controller,\n  Service,\n  Route,\n  Get,\n  Post,\n  Put,\n  Delete,\n  Patch,\n  Middleware,\n  Description,\n  Adapter,\n  Utility,\n  Model,\n  Repository,\n  Component,\n  View\n};\n\n// src/services/auth-manager.ts\nimport fs from \"fs\";\nimport path from \"path\";\nimport os from \"os\";\nimport axios from \"axios\";\nvar AuthManager = class {\n  constructor(config) {\n    this.config = {\n      verbose: false,\n      ...config\n    };\n    this.authFilePath = config.authFilePath || path.join(os.homedir(), \".wearesage-auth.json\");\n  }\n  // ===== TOKEN MANAGEMENT =====\n  /**\n   * Save authentication tokens to file\n   */\n  saveAuthTokens(tokens) {\n    try {\n      fs.writeFileSync(this.authFilePath, JSON.stringify(tokens, null, 2));\n      if (this.config.verbose) {\n        console.log(`\\u2705 Auth tokens saved to: ${this.authFilePath}`);\n      }\n    } catch (error) {\n      console.error(\"\\u274C Failed to save auth tokens:\", error);\n      throw error;\n    }\n  }\n  /**\n   * Load authentication tokens from file\n   */\n  loadAuthTokens() {\n    try {\n      if (!fs.existsSync(this.authFilePath)) {\n        return null;\n      }\n      const data = fs.readFileSync(this.authFilePath, \"utf8\");\n      const tokens = JSON.parse(data);\n      if (Date.now() > tokens.expiresAt) {\n        if (this.config.verbose) {\n          console.log(\"\\u26A0\\uFE0F  Stored tokens have expired\");\n        }\n        return null;\n      }\n      return tokens;\n    } catch (error) {\n      if (this.config.verbose) {\n        console.error(\"\\u274C Failed to load auth tokens:\", error);\n      }\n      return null;\n    }\n  }\n  /**\n   * Clear stored authentication tokens\n   */\n  clearTokens() {\n    try {\n      if (fs.existsSync(this.authFilePath)) {\n        fs.unlinkSync(this.authFilePath);\n        if (this.config.verbose) {\n          console.log(\"\\u2705 Auth tokens cleared\");\n        }\n      } else {\n        if (this.config.verbose) {\n          console.log(\"\\u2139\\uFE0F  No auth tokens to clear\");\n        }\n      }\n    } catch (error) {\n      console.error(\"\\u274C Failed to clear tokens:\", error);\n      throw error;\n    }\n  }\n  /**\n   * Check if tokens should be refreshed (within 5 minutes of expiry)\n   */\n  shouldRefreshToken(tokens) {\n    const timeUntilExpiry = tokens.expiresAt - Date.now();\n    const fiveMinutesInMs = 5 * 60 * 1e3;\n    return timeUntilExpiry < fiveMinutesInMs;\n  }\n  // ===== HTTP REQUESTS =====\n  /**\n   * Make authenticated HTTP request\n   */\n  async makeRequest(endpoint, data, token) {\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (token) {\n      headers.Authorization = `Bearer ${token}`;\n    }\n    return axios({\n      method: data ? \"POST\" : \"GET\",\n      url: `${this.config.apiBaseUrl}${endpoint}`,\n      headers,\n      data\n    });\n  }\n  // ===== WALLET SIGNATURE =====\n  /**\n   * Sign message with wallet private key\n   */\n  async signMessage(message, privateKey, walletType) {\n    if (walletType === \"ethereum\") {\n      const { Wallet } = await import(\"ethers\");\n      const wallet = new Wallet(privateKey);\n      return wallet.signMessageSync(message);\n    } else if (walletType === \"solana\") {\n      const { Keypair } = await import(\"@solana/web3.js\");\n      const bs58 = await import(\"bs58\");\n      const keypair = Keypair.fromSecretKey(bs58.default.decode(privateKey));\n      const messageBytes = new TextEncoder().encode(message);\n      const nacl = await import(\"tweetnacl\");\n      const signature = nacl.default.sign.detached(messageBytes, keypair.secretKey);\n      return bs58.default.encode(signature);\n    } else {\n      throw new Error(`Unsupported wallet type: ${walletType}`);\n    }\n  }\n  // ===== AUTHENTICATION FLOW =====\n  /**\n   * Request authentication challenge from server\n   */\n  async requestChallenge(walletAddress) {\n    try {\n      if (this.config.verbose) {\n        console.log(`\\u{1F504} Requesting challenge for wallet: ${walletAddress}`);\n      }\n      const response = await this.makeRequest(\"/api/auth/challenge\", { address: walletAddress });\n      const challenge = response.data.message;\n      if (this.config.verbose) {\n        console.log(`\\u2705 Received challenge: ${challenge}`);\n      }\n      return challenge;\n    } catch (error) {\n      const message = error.response?.data?.message || error.message;\n      console.error(\"\\u274C Failed to request challenge:\", message);\n      throw new Error(`Challenge request failed: ${message}`);\n    }\n  }\n  /**\n   * Authenticate with wallet signature\n   */\n  async authenticate(walletAddress, privateKey, walletType) {\n    try {\n      if (!isValidWalletAddress(walletAddress)) {\n        throw new Error(\"Invalid wallet address format\");\n      }\n      const detectedType = walletType || detectWalletType(walletAddress);\n      if (!detectedType) {\n        throw new Error(\"Could not determine wallet type from address\");\n      }\n      const normalizedKey = normalizePrivateKey(privateKey, detectedType);\n      if (this.config.verbose) {\n        console.log(`\\u{1F680} Starting authentication for ${detectedType} wallet: ${walletAddress}`);\n      }\n      const challenge = await this.requestChallenge(walletAddress);\n      if (this.config.verbose) {\n        console.log(`\\u270D\\uFE0F  Signing challenge: \"${challenge}\"`);\n      }\n      const signature = await this.signMessage(challenge, normalizedKey, detectedType);\n      if (this.config.verbose) {\n        console.log(\"\\u{1F510} Verifying signature...\");\n      }\n      const verifyRequest = {\n        address: walletAddress,\n        signature,\n        message: challenge\n      };\n      const response = await this.makeRequest(\"/api/auth/verify\", verifyRequest);\n      let accessToken;\n      let refreshToken;\n      let user;\n      if (response.data.tokens) {\n        accessToken = response.data.tokens.accessToken;\n        refreshToken = response.data.tokens.refreshToken;\n        user = response.data.user;\n      } else {\n        accessToken = response.data.accessToken;\n        refreshToken = response.data.refreshToken;\n        user = response.data.user;\n      }\n      if (!accessToken) {\n        throw new Error(\"No access token received from server\");\n      }\n      const tokens = {\n        accessToken,\n        refreshToken,\n        walletAddress,\n        walletType: detectedType,\n        expiresAt: Date.now() + 24 * 60 * 60 * 1e3,\n        // 24 hours\n        user\n      };\n      this.saveAuthTokens(tokens);\n      if (this.config.verbose) {\n        console.log(\"\\u{1F389} Authentication successful!\");\n        console.log(`\\u{1F464} User: ${user?.walletAddress} (Role: ${user?.role})`);\n      }\n      return tokens;\n    } catch (error) {\n      const message = error.response?.data?.message || error.message;\n      console.error(\"\\u274C Authentication failed:\", message);\n      throw new Error(`Authentication failed: ${message}`);\n    }\n  }\n  /**\n   * Refresh authentication tokens\n   */\n  async refreshTokens() {\n    try {\n      const stored = this.loadAuthTokens();\n      if (!stored) {\n        if (this.config.verbose) {\n          console.log(\"\\u274C No stored tokens to refresh\");\n        }\n        return null;\n      }\n      if (this.config.verbose) {\n        console.log(\"\\u{1F504} Refreshing tokens...\");\n      }\n      const refreshRequest = {\n        refreshToken: stored.refreshToken\n      };\n      const response = await this.makeRequest(\"/api/auth/refresh\", refreshRequest);\n      let accessToken;\n      let refreshToken;\n      if (response.data.tokens) {\n        accessToken = response.data.tokens.accessToken;\n        refreshToken = response.data.tokens.refreshToken;\n      } else {\n        accessToken = response.data.accessToken;\n        refreshToken = response.data.refreshToken;\n      }\n      if (!accessToken) {\n        if (this.config.verbose) {\n          console.log(\"\\u274C No access token in refresh response\");\n        }\n        return null;\n      }\n      const tokens = {\n        ...stored,\n        accessToken,\n        refreshToken: refreshToken || stored.refreshToken,\n        // Keep old refresh token if not provided\n        expiresAt: Date.now() + 24 * 60 * 60 * 1e3\n      };\n      this.saveAuthTokens(tokens);\n      if (this.config.verbose) {\n        console.log(\"\\u2705 Tokens refreshed successfully\");\n      }\n      return tokens;\n    } catch (error) {\n      const message = error.response?.data?.message || error.message;\n      if (this.config.verbose) {\n        console.log(\"\\u274C Token refresh failed:\", message);\n      }\n      return null;\n    }\n  }\n  /**\n   * Validate current authentication token\n   */\n  async validateToken() {\n    try {\n      const stored = this.loadAuthTokens();\n      if (!stored) {\n        if (this.config.verbose) {\n          console.log(\"\\u274C No stored tokens found\");\n        }\n        return false;\n      }\n      if (this.config.verbose) {\n        console.log(\"\\u{1F50D} Validating token...\");\n      }\n      const response = await this.makeRequest(\"/api/auth/validate\", void 0, stored.accessToken);\n      if (this.config.verbose) {\n        console.log(\"\\u2705 Token is valid\");\n        console.log(`\\u{1F464} Authenticated as: ${response.data.walletAddress}`);\n        console.log(`\\u{1F3AD} Role: ${response.data.role}`);\n      }\n      return true;\n    } catch (error) {\n      const message = error.response?.data?.message || error.message;\n      if (this.config.verbose) {\n        console.error(\"\\u274C Token validation failed:\", message);\n      }\n      return false;\n    }\n  }\n  /**\n   * Get authentication status and user info\n   */\n  async getAuthStatus() {\n    const tokens = this.loadAuthTokens();\n    if (!tokens) {\n      return { authenticated: false };\n    }\n    const isValid = await this.validateToken();\n    return {\n      authenticated: isValid,\n      user: tokens.user,\n      tokens: isValid ? tokens : void 0\n    };\n  }\n  /**\n   * Ensure valid authentication (refresh if needed)\n   */\n  async ensureValidAuth() {\n    let tokens = this.loadAuthTokens();\n    if (!tokens) {\n      return null;\n    }\n    if (this.shouldRefreshToken(tokens)) {\n      const refreshedTokens = await this.refreshTokens();\n      if (refreshedTokens) {\n        tokens = refreshedTokens;\n      }\n    }\n    return tokens;\n  }\n  /**\n   * Export tokens for external use (curl, etc.)\n   */\n  exportForCurl() {\n    const tokens = this.loadAuthTokens();\n    if (!tokens) {\n      console.log(\"\\u274C No authentication tokens found\");\n      return;\n    }\n    console.log(\"\\n\\u{1F4CB} cURL Export:\");\n    console.log(\"\\u2550\".repeat(50));\n    console.log(`export AUTH_TOKEN=\"${tokens.accessToken}\"`);\n    console.log(`export API_BASE_URL=\"${this.config.apiBaseUrl}\"`);\n    console.log(\"\");\n    console.log(\"# Example usage:\");\n    console.log('curl -H \"Authorization: Bearer $AUTH_TOKEN\" \"$API_BASE_URL/api/users/me\"');\n    console.log('curl -H \"Authorization: Bearer $AUTH_TOKEN\" \"$API_BASE_URL/api/projects\"');\n    console.log(\"\\u2550\".repeat(50));\n  }\n};\n\n// src/services/api-client.ts\nimport axios2 from \"axios\";\nvar ApiClient = class {\n  constructor(config) {\n    this.config = {\n      timeout: 1e4,\n      retries: 3,\n      verbose: false,\n      ...config\n    };\n    this.authManager = config.authManager;\n  }\n  // ===== QUERY BUILDING =====\n  /**\n   * Build query string from parameters\n   */\n  buildQueryString(params) {\n    const sanitized = sanitizeQueryParams(params);\n    const entries = Object.entries(sanitized);\n    if (entries.length === 0) {\n      return \"\";\n    }\n    const queryParts = entries.map(([key, value]) => {\n      return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n    });\n    return `?${queryParts.join(\"&\")}`;\n  }\n  /**\n   * Normalize endpoint path\n   */\n  normalizeEndpoint(endpoint) {\n    let normalized = endpoint.trim();\n    if (!normalized.startsWith(\"/\")) {\n      normalized = `/${normalized}`;\n    }\n    return normalized;\n  }\n  // ===== REQUEST EXECUTION =====\n  /**\n   * Execute HTTP request with retry logic\n   */\n  async executeRequest(config, options = {}) {\n    const maxRetries = options.retries || this.config.retries || 3;\n    let lastError;\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        if (options.verbose && !options.silent) {\n          console.log(`\\u{1F504} Attempt ${attempt + 1}/${maxRetries + 1}: ${config.method?.toUpperCase()} ${config.url}`);\n        }\n        const response = await axios2(config);\n        if (options.verbose && !options.silent) {\n          console.log(`\\u2705 Request successful: ${response.status} ${response.statusText}`);\n        }\n        return response;\n      } catch (error) {\n        lastError = error;\n        if (error.response?.status >= 400 && error.response?.status < 500) {\n          break;\n        }\n        if (attempt === maxRetries) {\n          break;\n        }\n        if (options.verbose && !options.silent) {\n          console.log(`\\u26A0\\uFE0F  Attempt ${attempt + 1} failed, retrying...`);\n        }\n        const delay = Math.min(1e3 * Math.pow(2, attempt), 5e3);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n    throw lastError;\n  }\n  // ===== AUTHENTICATED REQUESTS =====\n  /**\n   * Make authenticated request with automatic token refresh\n   */\n  async makeAuthenticatedRequest(method, endpoint, data, params, options = {}) {\n    if (!this.authManager) {\n      throw new Error(\"AuthManager not configured for authenticated requests\");\n    }\n    const tokens = await this.authManager.ensureValidAuth();\n    if (!tokens) {\n      throw new Error(\"No valid authentication tokens available\");\n    }\n    const normalizedEndpoint = this.normalizeEndpoint(endpoint);\n    const queryString = params ? this.buildQueryString(params) : \"\";\n    const url = `${this.config.baseUrl}${normalizedEndpoint}${queryString}`;\n    const requestConfig = {\n      method,\n      url,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${tokens.accessToken}`,\n        ...options.headers\n      },\n      data,\n      timeout: options.timeout || this.config.timeout\n    };\n    if (options.verbose && !options.silent) {\n      console.log(\"\\u{1F50D} Request config:\", {\n        method: requestConfig.method,\n        url: requestConfig.url,\n        headers: requestConfig.headers,\n        data: requestConfig.data\n      });\n    }\n    try {\n      const response = await this.executeRequest(requestConfig, options);\n      if (options.includeHeaders) {\n        return {\n          data: response.data,\n          status: response.status,\n          statusText: response.statusText,\n          headers: response.headers\n        };\n      }\n      return {\n        data: response.data,\n        status: response.status,\n        statusText: response.statusText,\n        headers: {}\n      };\n    } catch (error) {\n      if (error.response?.status === 401) {\n        if (options.verbose && !options.silent) {\n          console.log(\"\\u{1F504} 401 error, attempting token refresh...\");\n        }\n        const refreshedTokens = await this.authManager.refreshTokens();\n        if (refreshedTokens) {\n          requestConfig.headers.Authorization = `Bearer ${refreshedTokens.accessToken}`;\n          try {\n            const retryResponse = await this.executeRequest(requestConfig, options);\n            if (options.includeHeaders) {\n              return {\n                data: retryResponse.data,\n                status: retryResponse.status,\n                statusText: retryResponse.statusText,\n                headers: retryResponse.headers\n              };\n            }\n            return {\n              data: retryResponse.data,\n              status: retryResponse.status,\n              statusText: retryResponse.statusText,\n              headers: {}\n            };\n          } catch (retryError) {\n            if (!options.silent) {\n              console.error(`\\u274C Request failed after token refresh: ${formatError(retryError)}`);\n            }\n            throw retryError;\n          }\n        } else {\n          if (!options.silent) {\n            console.error(\"\\u274C Token refresh failed. Please re-authenticate.\");\n          }\n          throw new Error(\"Authentication failed\");\n        }\n      }\n      if (!options.silent) {\n        console.error(`\\u274C Request failed: ${formatError(error)}`);\n      }\n      throw error;\n    }\n  }\n  // ===== PUBLIC REQUESTS =====\n  /**\n   * Make public (non-authenticated) request\n   */\n  async makePublicRequest(method, endpoint, data, params, options = {}) {\n    const normalizedEndpoint = this.normalizeEndpoint(endpoint);\n    const queryString = params ? this.buildQueryString(params) : \"\";\n    const url = `${this.config.baseUrl}${normalizedEndpoint}${queryString}`;\n    const requestConfig = {\n      method,\n      url,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options.headers\n      },\n      data,\n      timeout: options.timeout || this.config.timeout\n    };\n    if (options.verbose && !options.silent) {\n      console.log(\"\\u{1F50D} Public request config:\", {\n        method: requestConfig.method,\n        url: requestConfig.url,\n        headers: requestConfig.headers,\n        data: requestConfig.data\n      });\n    }\n    try {\n      const response = await this.executeRequest(requestConfig, options);\n      if (options.includeHeaders) {\n        return {\n          data: response.data,\n          status: response.status,\n          statusText: response.statusText,\n          headers: response.headers\n        };\n      }\n      return {\n        data: response.data,\n        status: response.status,\n        statusText: response.statusText,\n        headers: {}\n      };\n    } catch (error) {\n      if (!options.silent) {\n        console.error(`\\u274C Public request failed: ${formatError(error)}`);\n      }\n      throw error;\n    }\n  }\n  // ===== CONVENIENCE METHODS =====\n  /**\n   * GET request\n   */\n  async get(endpoint, params, options = {}) {\n    if (this.authManager) {\n      return this.makeAuthenticatedRequest(\"GET\", endpoint, void 0, params, options);\n    } else {\n      return this.makePublicRequest(\"GET\", endpoint, void 0, params, options);\n    }\n  }\n  /**\n   * POST request\n   */\n  async post(endpoint, data, options = {}) {\n    if (this.authManager) {\n      return this.makeAuthenticatedRequest(\"POST\", endpoint, data, void 0, options);\n    } else {\n      return this.makePublicRequest(\"POST\", endpoint, data, void 0, options);\n    }\n  }\n  /**\n   * PUT request\n   */\n  async put(endpoint, data, options = {}) {\n    if (this.authManager) {\n      return this.makeAuthenticatedRequest(\"PUT\", endpoint, data, void 0, options);\n    } else {\n      return this.makePublicRequest(\"PUT\", endpoint, data, void 0, options);\n    }\n  }\n  /**\n   * DELETE request\n   */\n  async delete(endpoint, options = {}) {\n    if (this.authManager) {\n      return this.makeAuthenticatedRequest(\"DELETE\", endpoint, void 0, void 0, options);\n    } else {\n      return this.makePublicRequest(\"DELETE\", endpoint, void 0, void 0, options);\n    }\n  }\n  /**\n   * PATCH request\n   */\n  async patch(endpoint, data, options = {}) {\n    if (this.authManager) {\n      return this.makeAuthenticatedRequest(\"PATCH\", endpoint, data, void 0, options);\n    } else {\n      return this.makePublicRequest(\"PATCH\", endpoint, data, void 0, options);\n    }\n  }\n  // ===== UTILITY METHODS =====\n  /**\n   * Test API connectivity\n   */\n  async testConnection() {\n    try {\n      const response = await this.makePublicRequest(\"GET\", \"/health\", void 0, void 0, { silent: true });\n      return response.status >= 200 && response.status < 300;\n    } catch {\n      return false;\n    }\n  }\n  /**\n   * Update base URL\n   */\n  updateBaseUrl(baseUrl) {\n    this.config.baseUrl = baseUrl;\n  }\n  /**\n   * Set auth manager\n   */\n  setAuthManager(authManager) {\n    this.authManager = authManager;\n  }\n  /**\n   * Get current configuration\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n};\n\n// src/services/config-manager.ts\nimport fs2 from \"fs\";\nimport path2 from \"path\";\nimport os2 from \"os\";\nvar ConfigManager = class {\n  constructor(options = {}) {\n    this.cache = null;\n    this.options = {\n      configDir: path2.join(os2.homedir(), \".wearesage\"),\n      configFileName: \"config.json\",\n      createIfMissing: true,\n      verbose: false,\n      ...options\n    };\n    this.configPath = path2.join(this.options.configDir, this.options.configFileName);\n  }\n  // ===== FILE OPERATIONS =====\n  /**\n   * Ensure config directory exists\n   */\n  ensureConfigDir() {\n    if (!fs2.existsSync(this.options.configDir)) {\n      fs2.mkdirSync(this.options.configDir, { recursive: true });\n      if (this.options.verbose) {\n        console.log(`\\u2705 Created config directory: ${this.options.configDir}`);\n      }\n    }\n  }\n  /**\n   * Load configuration from file\n   */\n  load() {\n    try {\n      if (!fs2.existsSync(this.configPath)) {\n        if (this.options.createIfMissing) {\n          return this.createDefault();\n        } else {\n          throw new Error(`Config file not found: ${this.configPath}`);\n        }\n      }\n      const data = fs2.readFileSync(this.configPath, \"utf8\");\n      const config = JSON.parse(data);\n      this.cache = config;\n      if (this.options.verbose) {\n        console.log(`\\u2705 Config loaded from: ${this.configPath}`);\n      }\n      return config;\n    } catch (error) {\n      if (this.options.verbose) {\n        console.error(\"\\u274C Failed to load config:\", error.message);\n      }\n      if (this.options.createIfMissing && error.code === \"ENOENT\") {\n        return this.createDefault();\n      }\n      throw new Error(`Failed to load config: ${error.message}`);\n    }\n  }\n  /**\n   * Save configuration to file\n   */\n  save(config) {\n    try {\n      this.ensureConfigDir();\n      const configJson = JSON.stringify(config, null, 2);\n      fs2.writeFileSync(this.configPath, configJson, \"utf8\");\n      this.cache = config;\n      if (this.options.verbose) {\n        console.log(`\\u2705 Config saved to: ${this.configPath}`);\n      }\n    } catch (error) {\n      console.error(\"\\u274C Failed to save config:\", error.message);\n      throw new Error(`Failed to save config: ${error.message}`);\n    }\n  }\n  /**\n   * Create default configuration\n   */\n  createDefault() {\n    const defaultConfig = {};\n    this.save(defaultConfig);\n    return defaultConfig;\n  }\n  // ===== CONFIGURATION ACCESS =====\n  /**\n   * Get configuration value\n   */\n  get(key) {\n    const config = this.cache || this.load();\n    return config[key];\n  }\n  /**\n   * Set configuration value\n   */\n  set(key, value) {\n    const config = this.cache || this.load();\n    config[key] = value;\n    this.save(config);\n  }\n  /**\n   * Get multiple configuration values\n   */\n  getMultiple(keys) {\n    const config = this.cache || this.load();\n    const result = {};\n    for (const key of keys) {\n      if (key in config) {\n        result[key] = config[key];\n      }\n    }\n    return result;\n  }\n  /**\n   * Set multiple configuration values\n   */\n  setMultiple(values) {\n    const config = this.cache || this.load();\n    Object.assign(config, values);\n    this.save(config);\n  }\n  /**\n   * Get entire configuration\n   */\n  getAll() {\n    return this.cache || this.load();\n  }\n  /**\n   * Update configuration with merge\n   */\n  update(updates) {\n    const config = this.cache || this.load();\n    const updated = { ...config, ...updates };\n    this.save(updated);\n  }\n  /**\n   * Reset configuration to defaults\n   */\n  reset() {\n    this.cache = null;\n    if (fs2.existsSync(this.configPath)) {\n      fs2.unlinkSync(this.configPath);\n    }\n    return this.createDefault();\n  }\n  // ===== UTILITY METHODS =====\n  /**\n   * Check if configuration exists\n   */\n  exists() {\n    return fs2.existsSync(this.configPath);\n  }\n  /**\n   * Get configuration file path\n   */\n  getConfigPath() {\n    return this.configPath;\n  }\n  /**\n   * Validate configuration\n   */\n  validate(config) {\n    return { valid: true, errors: [] };\n  }\n};\nvar CliConfigManager = class extends ConfigManager {\n  createDefault() {\n    const defaultConfig = {\n      apiUrl: \"http://localhost:2223\",\n      outputFormat: \"pretty\",\n      autoCorrect: true,\n      verbose: false,\n      auth: {},\n      ai: {\n        ollamaModel: \"gemma3:12b-it-qat\",\n        maxTokens: 4e3,\n        temperature: 0.7\n      }\n    };\n    this.save(defaultConfig);\n    return defaultConfig;\n  }\n  validate(config) {\n    const errors = [];\n    if (config.apiUrl && !isValidUrl(config.apiUrl)) {\n      errors.push(\"Invalid API URL format\");\n    }\n    if (config.outputFormat && !isValidOutputFormat(config.outputFormat)) {\n      errors.push(\"Invalid output format. Must be: pretty, json, yaml, table, or csv\");\n    }\n    if (config.ai?.maxTokens && (config.ai.maxTokens < 100 || config.ai.maxTokens > 1e4)) {\n      errors.push(\"AI maxTokens must be between 100 and 10000\");\n    }\n    if (config.ai?.temperature && (config.ai.temperature < 0 || config.ai.temperature > 2)) {\n      errors.push(\"AI temperature must be between 0 and 2\");\n    }\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n  // CLI-specific helper methods\n  getApiUrl() {\n    return this.get(\"apiUrl\") || \"http://localhost:2223\";\n  }\n  setApiUrl(url) {\n    const validation = this.validate({ apiUrl: url });\n    if (!validation.valid) {\n      throw new Error(`Invalid API URL: ${validation.errors.join(\", \")}`);\n    }\n    this.set(\"apiUrl\", url);\n  }\n  getOutputFormat() {\n    return this.get(\"outputFormat\") || \"pretty\";\n  }\n  setOutputFormat(format) {\n    const validation = this.validate({ outputFormat: format });\n    if (!validation.valid) {\n      throw new Error(`Invalid output format: ${validation.errors.join(\", \")}`);\n    }\n    this.set(\"outputFormat\", format);\n  }\n  isVerbose() {\n    return this.get(\"verbose\") || false;\n  }\n  setVerbose(verbose) {\n    this.set(\"verbose\", verbose);\n  }\n  getOllamaModel() {\n    return this.get(\"ai\")?.ollamaModel || \"gemma3:12b-it-qat\";\n  }\n  setOllamaModel(model) {\n    const ai = this.get(\"ai\") || { ollamaModel: \"\", maxTokens: 4e3, temperature: 0.7 };\n    ai.ollamaModel = model;\n    this.set(\"ai\", ai);\n  }\n};\nvar ApiConfigManager = class extends ConfigManager {\n  createDefault() {\n    const defaultConfig = {\n      port: 2223,\n      host: \"0.0.0.0\",\n      cors: {\n        origin: [\"http://localhost:2223\", \"http://localhost:5173\"],\n        credentials: true\n      },\n      rateLimit: {\n        windowMs: 15 * 60 * 1e3,\n        // 15 minutes\n        max: 1e3\n        // requests per window\n      },\n      auth: {\n        jwtSecret: process.env.JWT_SECRET || \"dev-secret-change-in-production\",\n        tokenExpiry: \"24h\",\n        refreshTokenExpiry: \"7d\"\n      },\n      database: {\n        url: process.env.DATABASE_URL || \"postgresql://localhost/wearesage_dev\",\n        maxConnections: 20\n      },\n      redis: {\n        url: process.env.REDIS_URL || \"redis://localhost:6379\",\n        keyPrefix: \"ws:\"\n      }\n    };\n    this.save(defaultConfig);\n    return defaultConfig;\n  }\n  validate(config) {\n    const errors = [];\n    if (config.port && (config.port < 1 || config.port > 65535)) {\n      errors.push(\"Port must be between 1 and 65535\");\n    }\n    if (config.database?.url && !config.database.url.includes(\"://\")) {\n      errors.push(\"Database URL must include protocol (postgresql://, mysql://, etc.)\");\n    }\n    if (config.redis?.url && !config.redis.url.includes(\"://\")) {\n      errors.push(\"Redis URL must include protocol (redis://, rediss://)\");\n    }\n    if (config.rateLimit?.max && config.rateLimit.max < 1) {\n      errors.push(\"Rate limit max must be greater than 0\");\n    }\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n};\nvar EnvironmentManager = class {\n  /**\n   * Get environment variables with defaults\n   */\n  static getEnvironment() {\n    return {\n      NODE_ENV: process.env.NODE_ENV || \"development\",\n      API_URL: process.env.API_URL,\n      DATABASE_URL: process.env.DATABASE_URL,\n      REDIS_URL: process.env.REDIS_URL,\n      JWT_SECRET: process.env.JWT_SECRET,\n      SAGE_API_URL: process.env.SAGE_API_URL,\n      SAGE_WALLET_ADDRESS: process.env.SAGE_WALLET_ADDRESS,\n      SAGE_PRIVATE_KEY: process.env.SAGE_PRIVATE_KEY,\n      SAGE_AUTH_TOKEN: process.env.SAGE_AUTH_TOKEN,\n      SAGE_OUTPUT_FORMAT: process.env.SAGE_OUTPUT_FORMAT\n    };\n  }\n  /**\n   * Check if running in production\n   */\n  static isProduction() {\n    return process.env.NODE_ENV === \"production\";\n  }\n  /**\n   * Check if running in development\n   */\n  static isDevelopment() {\n    return process.env.NODE_ENV === \"development\" || !process.env.NODE_ENV;\n  }\n  /**\n   * Check if running in test\n   */\n  static isTest() {\n    return process.env.NODE_ENV === \"test\";\n  }\n  /**\n   * Get required environment variable\n   */\n  static getRequired(key) {\n    const value = process.env[key];\n    if (!value) {\n      throw new Error(`Required environment variable ${key} is not set`);\n    }\n    return value;\n  }\n  /**\n   * Get environment variable with default\n   */\n  static get(key, defaultValue) {\n    return process.env[key] || defaultValue;\n  }\n};\n\n// src/services/query-builder.ts\nvar QueryBuilder = class {\n  constructor(options = {}) {\n    this.resolver = getSmartEnumResolver();\n    this.options = {\n      autoResolveEnums: true,\n      allowUnresolved: true,\n      verbose: false,\n      ...options\n    };\n  }\n  // ===== SYNTAX PARSING =====\n  /**\n   * Parse function-style parameters: users(usa,spotify,mobile)\n   */\n  parseFunctionStyle(input) {\n    const match = input.match(/\\(([^)]+)\\)/);\n    if (!match) {\n      return [];\n    }\n    const content = match[1];\n    const terms = [];\n    const parts = this.splitWithQuotes(content, \",\");\n    for (const part of parts) {\n      const trimmed = part.trim();\n      if (!trimmed) continue;\n      if (trimmed.includes(\"=\")) {\n        const [key, ...valueParts] = trimmed.split(\"=\");\n        const value = valueParts.join(\"=\").trim();\n        const cleanValue = this.removeQuotes(value);\n        terms.push({\n          raw: `${key.trim()}=${cleanValue}`,\n          type: \"literal\"\n        });\n      } else {\n        const cleanTerm = this.removeQuotes(trimmed);\n        terms.push({\n          raw: cleanTerm,\n          type: \"enum\"\n        });\n      }\n    }\n    return terms;\n  }\n  /**\n   * Parse query string style: ?country=USA&source=SPOTIFY\n   */\n  parseQueryString(input) {\n    if (!input.includes(\"?\")) {\n      return [];\n    }\n    const queryPart = input.split(\"?\")[1];\n    const terms = [];\n    const params = new URLSearchParams(queryPart);\n    for (const [key, value] of params.entries()) {\n      terms.push({\n        raw: `${key}=${value}`,\n        type: \"literal\"\n      });\n    }\n    return terms;\n  }\n  /**\n   * Parse JSON object style: {\"country\":\"USA\",\"source\":\"SPOTIFY\"}\n   */\n  parseJsonStyle(input) {\n    const parseResult = safeJSONParse(input);\n    if (!parseResult.success) {\n      return [];\n    }\n    const terms = [];\n    const obj = parseResult.data;\n    if (typeof obj === \"object\" && obj !== null) {\n      for (const [key, value] of Object.entries(obj)) {\n        terms.push({\n          raw: `${key}=${String(value)}`,\n          type: \"literal\"\n        });\n      }\n    }\n    return terms;\n  }\n  // ===== UTILITY METHODS =====\n  /**\n   * Split string by delimiter while respecting quoted strings\n   */\n  splitWithQuotes(input, delimiter) {\n    const parts = [];\n    let current = \"\";\n    let inQuotes = false;\n    let quoteChar = \"\";\n    for (let i = 0; i < input.length; i++) {\n      const char = input[i];\n      if ((char === '\"' || char === \"'\") && !inQuotes) {\n        inQuotes = true;\n        quoteChar = char;\n        current += char;\n      } else if (char === quoteChar && inQuotes) {\n        inQuotes = false;\n        quoteChar = \"\";\n        current += char;\n      } else if (char === delimiter && !inQuotes) {\n        parts.push(current);\n        current = \"\";\n      } else {\n        current += char;\n      }\n    }\n    if (current) {\n      parts.push(current);\n    }\n    return parts;\n  }\n  /**\n   * Remove surrounding quotes from string\n   */\n  removeQuotes(input) {\n    const trimmed = input.trim();\n    if (trimmed.startsWith('\"') && trimmed.endsWith('\"') || trimmed.startsWith(\"'\") && trimmed.endsWith(\"'\")) {\n      return trimmed.slice(1, -1);\n    }\n    return trimmed;\n  }\n  // ===== ENUM RESOLUTION =====\n  /**\n   * Resolve terms using smart enum mapping\n   */\n  resolveTerms(terms) {\n    if (!this.options.autoResolveEnums) {\n      return terms;\n    }\n    return terms.map((term) => {\n      if (term.type === \"enum\") {\n        const resolved = this.resolver.resolve(term.raw);\n        if (resolved !== null) {\n          return {\n            ...term,\n            resolved\n          };\n        }\n      }\n      return term;\n    });\n  }\n  // ===== QUERY BUILDING =====\n  /**\n   * Convert resolved terms to query parameters\n   */\n  buildQueryParams(terms) {\n    const params = {};\n    for (const term of terms) {\n      if (term.type === \"literal\" && term.raw.includes(\"=\")) {\n        const [key, ...valueParts] = term.raw.split(\"=\");\n        const value = valueParts.join(\"=\");\n        params[key.trim()] = value;\n      } else if (term.type === \"enum\" && term.resolved !== void 0) {\n        const paramName = this.inferParameterName(term.resolved);\n        if (paramName) {\n          params[paramName] = String(term.resolved);\n        }\n      }\n    }\n    return sanitizeQueryParams(params);\n  }\n  /**\n   * Infer parameter name from enum value\n   * This maps enum ranges back to their likely parameter names\n   */\n  inferParameterName(enumValue) {\n    if (enumValue >= 0 && enumValue <= 3) return \"role\";\n    if (enumValue >= 1 && enumValue <= 7) return \"audioSource\";\n    if (enumValue >= 0 && enumValue <= 6) return \"deviceType\";\n    if (enumValue >= 13 && enumValue <= 23) return \"os\";\n    if (enumValue >= 24 && enumValue <= 70) return \"country\";\n    if (enumValue >= 71 && enumValue <= 75) return \"shaderType\";\n    if (enumValue >= 76 && enumValue <= 100) return \"tag\";\n    if (enumValue >= 101 && enumValue <= 107) return \"performance\";\n    if (enumValue >= 108 && enumValue <= 115) return \"quality\";\n    if (enumValue >= 116 && enumValue <= 130) return \"framework\";\n    if (enumValue >= 131 && enumValue <= 141) return \"timePeriod\";\n    if (enumValue >= 142 && enumValue <= 157) return \"sortBy\";\n    if (enumValue >= 158 && enumValue <= 161) return \"sortOrder\";\n    if (enumValue >= 162 && enumValue <= 169) return \"role\";\n    return null;\n  }\n  // ===== PUBLIC API =====\n  /**\n   * Parse query from various input formats\n   */\n  parseQuery(input) {\n    const suggestions = [];\n    const errors = [];\n    let terms = [];\n    if (this.options.verbose) {\n      console.log(`\\u{1F50D} Parsing query: \"${input}\"`);\n    }\n    if (input.includes(\"(\") && input.includes(\")\")) {\n      terms = this.parseFunctionStyle(input);\n      if (this.options.verbose) {\n        console.log(\"\\u{1F4DD} Detected function-style syntax\");\n      }\n    } else if (input.includes(\"?\")) {\n      terms = this.parseQueryString(input);\n      if (this.options.verbose) {\n        console.log(\"\\u{1F4DD} Detected query-string syntax\");\n      }\n    } else if (input.trim().startsWith(\"{\")) {\n      terms = this.parseJsonStyle(input);\n      if (this.options.verbose) {\n        console.log(\"\\u{1F4DD} Detected JSON syntax\");\n      }\n    } else {\n      terms = [{ raw: input.trim(), type: \"enum\" }];\n      if (this.options.verbose) {\n        console.log(\"\\u{1F4DD} Treating as single term\");\n      }\n    }\n    const resolvedTerms = this.resolveTerms(terms);\n    for (const term of resolvedTerms) {\n      if (term.type === \"enum\" && term.resolved === void 0) {\n        if (!this.options.allowUnresolved) {\n          errors.push(`Unresolved term: \"${term.raw}\"`);\n        }\n        const termSuggestions = this.resolver.getSuggestions(term.raw, 3);\n        suggestions.push(...termSuggestions);\n      }\n    }\n    const params = this.buildQueryParams(resolvedTerms);\n    if (this.options.verbose) {\n      console.log(\"\\u2705 Parse result:\", {\n        terms: resolvedTerms.length,\n        params: Object.keys(params).length,\n        suggestions: suggestions.length,\n        errors: errors.length\n      });\n    }\n    return {\n      terms: resolvedTerms,\n      params,\n      suggestions: [...new Set(suggestions)],\n      // Remove duplicates\n      errors\n    };\n  }\n  /**\n   * Build query string from smart terms\n   */\n  buildQueryString(input) {\n    const parsed = this.parseQuery(input);\n    if (parsed.errors.length > 0 && !this.options.allowUnresolved) {\n      throw new Error(`Query parsing failed: ${parsed.errors.join(\", \")}`);\n    }\n    const paramEntries = Object.entries(parsed.params);\n    if (paramEntries.length === 0) {\n      return \"\";\n    }\n    const queryParts = paramEntries.map(([key, value]) => {\n      return `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;\n    });\n    return `?${queryParts.join(\"&\")}`;\n  }\n  /**\n   * Get suggestions for a partial query\n   */\n  getSuggestions(input, limit = 5) {\n    let lastTerm = input;\n    if (input.includes(\"(\")) {\n      const parts = input.split(/[(),]/);\n      lastTerm = parts[parts.length - 1]?.trim() || \"\";\n    } else if (input.includes(\"&\")) {\n      const parts = input.split(\"&\");\n      lastTerm = parts[parts.length - 1]?.trim() || \"\";\n    }\n    return this.resolver.getSuggestions(lastTerm, limit);\n  }\n  /**\n   * Check if a query is valid\n   */\n  isValidQuery(input) {\n    try {\n      const parsed = this.parseQuery(input);\n      return parsed.errors.length === 0;\n    } catch {\n      return false;\n    }\n  }\n  /**\n   * Get available enum terms for autocomplete\n   */\n  getAvailableTerms() {\n    return [\n      \"usa\",\n      \"uk\",\n      \"canada\",\n      \"australia\",\n      \"spotify\",\n      \"audius\",\n      \"kexp\",\n      \"mobile\",\n      \"desktop\",\n      \"tablet\",\n      \"audio\",\n      \"generative\",\n      \"cyberpunk\",\n      \"today\",\n      \"week\",\n      \"month\",\n      \"year\",\n      \"popular\",\n      \"trending\",\n      \"featured\",\n      \"public\",\n      \"private\",\n      \"unlisted\"\n    ];\n  }\n};\nexport {\n  ADMIN_WALLET,\n  ActivityType,\n  Adapter,\n  AnalyticsMetric,\n  ApiClient,\n  ApiConfigManager,\n  AppTarget,\n  AudioSource,\n  AuthManager,\n  CORE_TEST_USERS,\n  CliConfigManager,\n  ClientPlatform,\n  CollaborationRole,\n  Component,\n  ConfigManager,\n  ConsciousnessMessageType,\n  ContentVisibility,\n  Controller,\n  Country,\n  CurrentPage,\n  DEFAULT_USER_PREFERENCES,\n  Delete,\n  Description,\n  DeviceType,\n  EXTENDED_TEST_USERS,\n  EmotionalTone,\n  EnvironmentManager,\n  Framework,\n  GeoRegion,\n  Get,\n  Middleware,\n  Model,\n  NoOp,\n  OperatingSystem,\n  Patch,\n  PerformanceLevel,\n  PlaybackState,\n  Post,\n  ProjectContext,\n  ProjectStatus,\n  Put,\n  Quality,\n  QueryBuilder,\n  RadioParadiseStation,\n  RadioSource,\n  RadioStreamUrls,\n  RedisKeys,\n  Repository,\n  Route,\n  RouterModeMap,\n  SMART_ENUM_MAP,\n  Service,\n  ShaderCategory,\n  ShaderType,\n  SmartEnumResolver,\n  SocketActivity,\n  SocketCore,\n  SocketCrud,\n  SocketEntity,\n  SocketEventCategories,\n  SocketEvents,\n  SocketRoom,\n  SocketSocial,\n  SortBy,\n  SortOrder,\n  SpaceType,\n  SpaceVisibility,\n  SpecialWallets,\n  TEST_USER_COLORS,\n  TEST_USER_DISPLAY_NAMES,\n  TEST_USER_SHORT_NAMES,\n  TaskPriority,\n  TaskStatus,\n  Team,\n  TechnicalContext,\n  TimePeriod,\n  UserRole,\n  UserStateField,\n  UserStatus,\n  Utility,\n  View,\n  VisualTag,\n  createProjectEvent,\n  createSocketEvent,\n  createTaskEvent,\n  detectWalletType,\n  enumKeyToLabel,\n  enumToString,\n  formatBytes,\n  formatDuration,\n  formatError,\n  formatJSON,\n  formatKey,\n  formatPercentage,\n  formatStatus,\n  formatTimestamp,\n  generateSocketEvent,\n  getEnumValues,\n  getMetadata,\n  getRoutes,\n  getSmartEnumResolver,\n  getTestUserByWallet,\n  getTestUserStats,\n  getTestUsersByRole,\n  getTestUsersForEnvironment,\n  hasDecorator,\n  isValidEndpoint,\n  isValidEnumValue,\n  isValidEthereumAddress,\n  isValidEthereumPrivateKey,\n  isValidHttpMethod,\n  isValidJSON,\n  isValidOutputFormat,\n  isValidSolanaAddress,\n  isValidSolanaPrivateKey,\n  isValidUrl,\n  isValidWalletAddress,\n  normalizePrivateKey,\n  resolveSmartEnum,\n  safeJSONParse,\n  sanitizeEndpoint,\n  sanitizeQueryParams,\n  sanitizeString,\n  sanitizeWalletAddress,\n  truncateAddress,\n  validatePagination\n};\n"],"names":["AudioSource","RadioParadiseStation"],"mappings":"AA4CA,IAAIA,EAAc,CAChB,KAAM,EACN,QAAS,EACT,OAAQ,EACR,eAAgB,EAChB,WAAY,EACZ,KAAM,EACN,cAAe,EACf,KAAM,CACR,EAKIC,EAAuB,CACzB,SAAU,EACV,WAAY,EACZ,SAAU,EACV,WAAY,CACd,EA+oBeD,EAAY,KA0ahBA,EAAY,QACfA,EAAY,QACVA,EAAY,OACfA,EAAY,OACVA,EAAY,eACJA,EAAY,eACjBA,EAAY,eAClBA,EAAY,eACVA,EAAY,KACNA,EAAY,WACnBA,EAAY,WACXA,EAAY,KACVA,EAAY,KACXA,EAAY","x_google_ignoreList":[0]}