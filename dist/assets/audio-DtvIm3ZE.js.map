{"version":3,"mappings":"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","names":["useAudio","defineStore","audioElement","ref","src","currentTrackId","toast","useToast","lastToastTrackId","checkForElement","element","audioSystem","interval","mediaControls","useMediaControls","currentTime","duration","playing","waiting","ended","mediaVolume","muted","enableTrack","play","success","pause","initializeAnalyser","volume","stream","cleanupAnalyser","analyserInitialized","useAudioAnalyser","raf","useRAF","now","result","initialized","isLoading","userGestureInitialized","computed","state","currentPosition","audioDuration","progress","setSource","url","seek","seconds","skip","newTime","setVolume","level","initializeAudio","audioContext","analyserNode","error","getAudioUrlForTrack","track","AudioSource","audiusTrackId","showNowPlayingToast","message","updateMediaSessionMetadata","useSources","__vitePreload","n","mediaConfig","art","playTrack","audioUrl","trackId","watch","trackEnded","useQueue","queue","handleCanPlay","handleLoadStart","cleanup"],"ignoreList":[],"sources":["../../../vue/src/stores/audio.ts"],"sourcesContent":["import { ref, computed, watch } from \"vue\";\nimport { defineStore, acceptHMRUpdate } from \"pinia\";\nimport { useMediaControls } from \"@vueuse/core\";\nimport { audioSystem } from \"../classes/AudioSystemManager\";\nimport { useAudioAnalyser } from \"../composables/audio/useAudioAnalyser\";\nimport { useRAF } from \"./raf\";\nimport { useToast } from \"./toast\";\nimport { AudioSource } from \"@wearesage/shared\";\n// import { api } from \"../api/client\";\n\nexport const useAudio = defineStore(\"audio\", () => {\n  // Audio element and source (managed by AudioSystemManager)\n  const audioElement = ref<HTMLAudioElement>();\n  const src = ref<string>(\"\");\n  const currentTrackId = ref<string | null>(null);\n\n  // Toast for \"Now Playing\" notifications\n  const toast = useToast();\n  const lastToastTrackId = ref<string | null>(null);\n\n  // Get element from audio system manager\n  if (typeof window !== \"undefined\") {\n    // Element will be created when user gesture happens\n    const checkForElement = () => {\n      const element = audioSystem.getAudioElement();\n      if (element && !audioElement.value) {\n        audioElement.value = element;\n        console.log(\"ðŸŽµ Audio element acquired from AudioSystemManager\");\n      }\n    };\n\n    // Check immediately and set up interval for when gesture happens\n    checkForElement();\n    const interval = setInterval(() => {\n      checkForElement();\n      if (audioElement.value) {\n        clearInterval(interval);\n      }\n    }, 100);\n  }\n\n  // Use VueUse media controls for comprehensive audio management\n  const mediaControls = useMediaControls(audioElement, {\n    src,\n  });\n\n  // Destructure with safer access\n  const { currentTime, duration, playing, waiting, ended, volume: mediaVolume, muted, enableTrack } = mediaControls;\n\n  // Use AudioSystemManager for bulletproof play/pause\n  const play = async () => {\n    console.log(\"ðŸ”Š Attempting to play audio...\");\n    const success = await audioSystem.playAudio();\n    if (success) {\n      console.log(\"ðŸ”Š Audio playing via AudioSystemManager\");\n    } else {\n      console.warn(\"ðŸ”Š AudioSystemManager playAudio() returned false\");\n    }\n    return success;\n  };\n\n  const pause = async () => {\n    audioSystem.pauseAudio();\n  };\n\n  // Audio analysis using the SAUCE (useAudioAnalyser + AudioSystemManager)\n  const { initialize: initializeAnalyser, volume, stream, cleanup: cleanupAnalyser, initialized: analyserInitialized } = useAudioAnalyser();\n\n  // RAF loop for continuous audio analysis (runs regardless of audio element state)\n  const raf = useRAF();\n  raf.add(\n    (now) => {\n      if (analyserInitialized.value) {\n        const result = audioSystem.tick(raf.frameRate);\n        volume.value = result.volume;\n        stream.value = result.stream;\n      }\n    },\n    { id: \"audio-analysis\" }\n  );\n\n  const initialized = ref(false);\n  const isLoading = ref(false);\n\n  // Track if audio system is initialized\n  const userGestureInitialized = computed(() => {\n    const state = audioSystem.getState();\n    return state.isPrimed && state.hasUserGesture;\n  });\n\n  // Convert to milliseconds for consistency with old API\n  const currentPosition = computed(() => currentTime.value * 1000);\n  const audioDuration = computed(() => duration.value * 1000);\n\n  // Progress tracking (0-1)\n  const progress = computed(() => {\n    return duration.value > 0 ? currentTime.value / duration.value : 0;\n  });\n\n  /**\n   * Set audio source URL using AudioSystemManager\n   */\n  function setSource(url: string) {\n    console.log(\"ðŸ”Š Setting audio source:\", url);\n    isLoading.value = true; // Start loading\n    src.value = url;\n    audioSystem.setAudioSource(url);\n  }\n\n  /**\n   * Seek to specific position (in seconds)\n   */\n  function seek(seconds: number) {\n    currentTime.value = seconds;\n  }\n\n  /**\n   * Skip forward/backward by specified seconds\n   */\n  function skip(seconds: number) {\n    const newTime = Math.max(0, Math.min(currentTime.value + seconds, duration.value || 0));\n    seek(newTime);\n  }\n\n  /**\n   * Set volume (0-1)\n   */\n  function setVolume(level: number) {\n    mediaVolume.value = Math.max(0, Math.min(1, level));\n  }\n\n  /**\n   * Initialize audio with user gesture using AudioSystemManager + AudioAnalyser\n   * Must be called synchronously within a user interaction event\n   */\n  async function initializeAudio() {\n    if (userGestureInitialized.value) {\n      console.log(\"ðŸ”Š Audio already initialized via AudioSystemManager\");\n      return true;\n    }\n\n    try {\n      console.log(\"ðŸ”Š Initializing audio system with user gesture...\");\n\n      // Prime the audio system synchronously\n      const success = audioSystem.primeAudioSystem();\n\n      if (success) {\n        // Get the primed audio element and context\n        audioElement.value = audioSystem.getAudioElement();\n        const audioContext = audioSystem.getAudioContext();\n        const analyserNode = audioSystem.getAnalyserNode();\n\n        if (audioElement.value) {\n          // Initialize the consolidated AudioSystemManager for audio element\n          await initializeAnalyser(audioElement.value);\n\n          initialized.value = true;\n          console.log(\"ðŸ”Š Audio system + AudioAnalyser initialized successfully!\");\n          return true;\n        } else {\n          console.warn(\"ðŸ”Š Missing audio components from AudioSystemManager\");\n          return false;\n        }\n      } else {\n        console.warn(\"ðŸ”Š Failed to prime audio system\");\n        return false;\n      }\n    } catch (error) {\n      console.error(\"ðŸ”Š Failed to initialize audio system:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Get audio URL for a queue track based on its source\n   */\n  function getAudioUrlForTrack(track: any): string | null {\n    if (!track) return null;\n\n    switch (track.source) {\n      case AudioSource.SPOTIFY:\n        // Spotify requires premium and Web Playback SDK - return null for now\n        console.warn(\"ðŸ”Š Spotify playback requires Web Playback SDK integration\");\n        return null;\n\n      case AudioSource.AUDIUS:\n        // Audius requires a separate API call to get the stream URL\n        // We need to get the track ID and make a request to our API\n        const audiusTrackId = track.rawData?.id || track.rawData?.audiusId || track.sourceId;\n\n        if (audiusTrackId) {\n          console.log(\"ðŸ”Š Audius track ID:\", audiusTrackId);\n          // Return a special marker that we'll handle in playTrack()\n          return `audius-stream:${audiusTrackId}`;\n        }\n\n        console.warn(\"ðŸ”Š No track ID found for Audius track:\", track);\n        console.warn(\"ðŸ”Š Available rawData fields:\", Object.keys(track.rawData || {}));\n        return null;\n\n      case AudioSource.RADIO_PARADISE:\n      case AudioSource.KEXP:\n        // Radio stations - would need live stream URLs\n        console.warn(\"ðŸ”Š Radio playback not yet implemented\");\n        return null;\n\n      case AudioSource.FILE:\n        // File source should have a direct URL\n        return track.rawData?.url || track.sourceId;\n\n      default:\n        console.warn(\"ðŸ”Š Unknown audio source:\", track.source);\n        return null;\n    }\n  }\n\n  /**\n   * Show \"Now Playing\" toast notification\n   */\n  function showNowPlayingToast(track: any) {\n    if (!track || track.id === lastToastTrackId.value) return;\n\n    console.log(\"ðŸŽµ Now Playing:\", track.title, \"by\", track.artist);\n\n    const message = `ðŸŽµ Now Playing: \"${track.title}\" by ${track.artist}`;\n    toast.message(message);\n\n    lastToastTrackId.value = track.id;\n  }\n\n  /**\n   * Update media session metadata for the currently loaded track\n   */\n  async function updateMediaSessionMetadata(track: any) {\n    if (!track) {\n      // Clear metadata if no track\n      if (\"mediaSession\" in navigator) {\n        navigator.mediaSession.metadata = null;\n      }\n      return;\n    }\n\n    try {\n      // Check if the current source supports metadata\n      const { useSources } = await import(\"./sources\");\n      const sources = useSources();\n      const mediaConfig = sources.mediaSessionManager.getCurrentConfig();\n\n      // Only update metadata if current source has media session enabled and supports metadata\n      if (!mediaConfig?.enabled || !mediaConfig.metadata) {\n        console.log(\"ðŸŽµ Skipping metadata update - current source does not support metadata\");\n        return;\n      }\n\n      // Use enableTrack if available and audio is properly initialized\n      if (typeof enableTrack === \"function\" && audioElement.value && userGestureInitialized.value) {\n        enableTrack({\n          title: track.title,\n          artist: track.artist,\n          album: track.album || \"\",\n          artwork: track.artwork\n            ? [\n                { src: track.artwork.small || \"\", sizes: \"64x64\", type: \"image/jpeg\" },\n                { src: track.artwork.medium || \"\", sizes: \"300x300\", type: \"image/jpeg\" },\n                { src: track.artwork.large || \"\", sizes: \"640x640\", type: \"image/jpeg\" },\n              ].filter((art) => art.src)\n            : [],\n        });\n\n        console.log(\"ðŸŽµ Updated track metadata via useMediaControls for:\", track.title);\n      } else {\n        // Fallback to manual Media Session API\n        if (\"mediaSession\" in navigator) {\n          navigator.mediaSession.metadata = new MediaMetadata({\n            title: track.title,\n            artist: track.artist,\n            album: track.album || \"\",\n            artwork: track.artwork\n              ? [\n                  { src: track.artwork.small || \"\", sizes: \"64x64\", type: \"image/jpeg\" },\n                  { src: track.artwork.medium || \"\", sizes: \"300x300\", type: \"image/jpeg\" },\n                  { src: track.artwork.large || \"\", sizes: \"640x640\", type: \"image/jpeg\" },\n                ].filter((art) => art.src)\n              : [],\n          });\n          console.log(\"ðŸŽµ Updated track metadata via fallback Media Session API for:\", track.title);\n        }\n      }\n    } catch (error) {\n      console.warn(\"Could not update media session metadata:\", error);\n    }\n  }\n\n  /**\n   * Load and play a queue track\n   */\n  async function playTrack(track: any) {\n    // Ensure audio is initialized before playing\n    if (!userGestureInitialized.value) {\n      console.log(\"ðŸ”Š Audio not initialized, initializing now...\");\n      const initSuccess = initializeAudio();\n      if (!initSuccess) {\n        console.error(\"ðŸ”Š Failed to initialize audio\");\n        return false;\n      }\n    }\n\n    const audioUrl = getAudioUrlForTrack(track);\n\n    if (!audioUrl) {\n      console.error(\"ðŸ”Š No playable audio URL for track:\", track);\n      // No fallback - just return false\n      return false;\n    }\n\n    console.log(\"ðŸ”Š Loading track:\", track.title, \"by\", track.artist);\n\n    // Update current track ID for duplicate prevention\n    currentTrackId.value = track.sourceId;\n\n    // Handle Audius stream URL fetching\n    if (audioUrl.startsWith(\"audius-stream:\")) {\n      const trackId = audioUrl.replace(\"audius-stream:\", \"\");\n\n      try {\n        console.log(\"ðŸ”Š Fetching Audius stream URL for track ID:\", trackId);\n\n        // // Call our API to get the stream URL using authenticated client\n        // const response = await api.get(`/api/audius/stream/${trackId}`);\n        // const { url: streamUrl } = response.data;\n\n        //   console.log(\"ðŸ”Š Got Audius stream URL:\", streamUrl);\n        //   setSource(streamUrl);\n\n        //   // Update media session metadata now that we're loading this track\n        //   await updateMediaSessionMetadata(track);\n\n        //   // Show \"Now Playing\" toast\n        //   showNowPlayingToast(track);\n        // } else {\n        // throw new Error(\"No stream URL returned\");\n        // }\n      } catch (error) {\n        console.error(\"ðŸ”Š Failed to fetch Audius stream URL:\", error);\n        // Clear current track ID on error\n        currentTrackId.value = null;\n        // No fallback - just return false\n        return false;\n      }\n    } else {\n      // Regular URL, use directly\n      setSource(audioUrl);\n\n      // Update media session metadata now that we're loading this track\n      await updateMediaSessionMetadata(track);\n\n      // Show \"Now Playing\" toast\n      showNowPlayingToast(track);\n    }\n\n    // Autoplay is enabled on the audio element, so just setting src should trigger playback\n    console.log(\"ðŸ”Š Track loaded with autoplay enabled\");\n    return true;\n  }\n\n  // Watch for track end to auto-advance\n  watch(ended, (trackEnded) => {\n    if (trackEnded) {\n      console.log(\"ðŸ”Š Track ended\");\n\n      // Try to get queue store for automatic progression\n      import(\"./queue\")\n        .then(({ useQueue }) => {\n          const queue = useQueue();\n\n          // Auto-advance to next track if available\n          if (queue.hasNext) {\n            console.log(\"ðŸ”Š Auto-advancing to next track\");\n            queue.nextTrack();\n          } else {\n            console.log(\"ðŸ”Š End of queue reached\");\n          }\n        })\n        .catch((error) => {\n          console.warn(\"Could not auto-advance track:\", error);\n        });\n    }\n  });\n\n  // Watch for audio element from AudioSystemManager\n  watch(\n    audioElement,\n    async (element) => {\n      if (element && !initialized.value) {\n        console.log(\"ðŸ”Š Audio element connected from AudioSystemManager\");\n\n        // Initialize with consolidated AudioSystemManager\n        await initializeAnalyser(element);\n        initialized.value = true;\n\n        // Set up loading state event listeners\n        const handleCanPlay = () => {\n          console.log(\"ðŸ”Š Audio can play - loading complete\");\n          isLoading.value = false;\n        };\n\n        const handleLoadStart = () => {\n          console.log(\"ðŸ”Š Audio load started\");\n          isLoading.value = true;\n        };\n\n        // Add event listeners for loading state\n        element.addEventListener(\"loadstart\", handleLoadStart);\n        element.addEventListener(\"canplay\", handleCanPlay);\n        element.addEventListener(\"playing\", handleCanPlay);\n\n        // Clean up event listeners when element changes\n        const cleanup = () => {\n          element.removeEventListener(\"loadstart\", handleLoadStart);\n          element.removeEventListener(\"canplay\", handleCanPlay);\n          element.removeEventListener(\"playing\", handleCanPlay);\n        };\n\n        // Store cleanup function for later use\n        (element as any)._audioLoadingCleanup = cleanup;\n      }\n    },\n    { immediate: true }\n  );\n\n  return {\n    // Core audio element (from useMediaControls)\n    element: audioElement,\n\n    // Audio state (from useMediaControls)\n    src,\n    playing,\n    currentPosition,\n    duration: audioDuration,\n    progress,\n    waiting,\n    ended,\n    muted,\n    isLoading,\n\n    // Audio analysis (from useAudioAnalyser - the SAUCE!)\n    volume, // Sophisticated volume analysis with smoothing\n    stream, // Stream animation with proper scaling\n    initialized: computed(() => initialized.value && analyserInitialized.value),\n    userGestureInitialized,\n\n    // Controls (from useMediaControls)\n    play,\n    pause,\n    toggle: () => (playing.value ? pause() : play()), // Add toggle for compatibility\n    seek,\n    skip,\n    setVolume,\n\n    // Media Session API (from useMediaControls)\n    enableTrack,\n\n    // Queue integration\n    setSource,\n    playTrack,\n    getAudioUrlForTrack,\n    initializeAudio,\n    currentTrackId,\n    updateMediaSessionMetadata,\n    showNowPlayingToast,\n  };\n});\n\nif (import.meta.hot) {\n  import.meta.hot.accept(acceptHMRUpdate(useAudio, import.meta.hot));\n}\n"],"file":"assets/audio-DtvIm3ZE.js"}