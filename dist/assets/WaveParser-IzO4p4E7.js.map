{"version":3,"file":"WaveParser-IzO4p4E7.js","sources":["../../node_modules/music-metadata/lib/riff/RiffChunk.js","../../node_modules/music-metadata/lib/wav/WaveChunk.js","../../node_modules/music-metadata/lib/wav/BwfChunk.js","../../node_modules/music-metadata/lib/wav/WaveParser.js"],"sourcesContent":["import * as Token from 'token-types';\n/**\n * Common RIFF chunk header\n */\nexport const Header = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Group-ID\n            chunkID: new Token.StringType(4, 'latin1').get(buf, off),\n            // Size\n            chunkSize: Token.UINT32_LE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Token to parse RIFF-INFO tag value\n */\nexport class ListInfoTagValue {\n    constructor(tagHeader) {\n        this.tagHeader = tagHeader;\n        this.len = tagHeader.chunkSize;\n        this.len += this.len & 1; // if it is an odd length, round up to even\n    }\n    get(buf, off) {\n        return new Token.StringType(this.tagHeader.chunkSize, 'ascii').get(buf, off);\n    }\n}\n//# sourceMappingURL=RiffChunk.js.map","import * as Token from 'token-types';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nexport class WaveContentError extends makeUnexpectedFileContentError('Wave') {\n}\n/**\n * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317599(v=vs.85).aspx\n */\nexport const WaveFormat = {\n    PCM: 0x0001,\n    // MPEG-4 and AAC Audio Types\n    ADPCM: 0x0002,\n    IEEE_FLOAT: 0x0003,\n    MPEG_ADTS_AAC: 0x1600,\n    MPEG_LOAS: 0x1602,\n    RAW_AAC1: 0x00FF,\n    // Dolby Audio Types\n    DOLBY_AC3_SPDIF: 0x0092,\n    DVM: 0x2000,\n    RAW_SPORT: 0x0240,\n    ESST_AC3: 0x0241,\n    DRM: 0x0009,\n    DTS2: 0x2001,\n    MPEG: 0x0050\n};\nexport const WaveFormatNameMap = {\n    [WaveFormat.PCM]: 'PCM',\n    [WaveFormat.ADPCM]: 'ADPCM',\n    [WaveFormat.IEEE_FLOAT]: 'IEEE_FLOAT',\n    [WaveFormat.MPEG_ADTS_AAC]: 'MPEG_ADTS_AAC',\n    [WaveFormat.MPEG_LOAS]: 'MPEG_LOAS',\n    [WaveFormat.RAW_AAC1]: 'RAW_AAC1',\n    [WaveFormat.DOLBY_AC3_SPDIF]: 'DOLBY_AC3_SPDIF',\n    [WaveFormat.DVM]: 'DVM',\n    [WaveFormat.RAW_SPORT]: 'RAW_SPORT',\n    [WaveFormat.ESST_AC3]: 'ESST_AC3',\n    [WaveFormat.DRM]: 'DRM',\n    [WaveFormat.DTS2]: 'DTS2',\n    [WaveFormat.MPEG]: 'MPEG'\n};\n/**\n * format chunk; chunk-id is \"fmt \"\n * http://soundfile.sapp.org/doc/WaveFormat/\n */\nexport class Format {\n    constructor(header) {\n        if (header.chunkSize < 16)\n            throw new WaveContentError('Invalid chunk size');\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        return {\n            wFormatTag: Token.UINT16_LE.get(buf, off),\n            nChannels: Token.UINT16_LE.get(buf, off + 2),\n            nSamplesPerSec: Token.UINT32_LE.get(buf, off + 4),\n            nAvgBytesPerSec: Token.UINT32_LE.get(buf, off + 8),\n            nBlockAlign: Token.UINT16_LE.get(buf, off + 12),\n            wBitsPerSample: Token.UINT16_LE.get(buf, off + 14)\n        };\n    }\n}\n/**\n * Fact chunk; chunk-id is \"fact\"\n * http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\n * http://www.recordingblogs.com/wiki/fact-chunk-of-a-wave-file\n */\nexport class FactChunk {\n    constructor(header) {\n        if (header.chunkSize < 4) {\n            throw new WaveContentError('Invalid fact chunk size.');\n        }\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        return {\n            dwSampleLength: Token.UINT32_LE.get(buf, off)\n        };\n    }\n}\n//# sourceMappingURL=WaveChunk.js.map","import * as Token from 'token-types';\nimport { stripNulls } from '../common/Util.js';\n/**\n * Broadcast Audio Extension Chunk\n * Ref: https://tech.ebu.ch/docs/tech/tech3285.pdf\n */\nexport const BroadcastAudioExtensionChunk = {\n    len: 420,\n    get: (uint8array, off) => {\n        return {\n            description: stripNulls(new Token.StringType(256, 'ascii').get(uint8array, off)).trim(),\n            originator: stripNulls(new Token.StringType(32, 'ascii').get(uint8array, off + 256)).trim(),\n            originatorReference: stripNulls(new Token.StringType(32, 'ascii').get(uint8array, off + 288)).trim(),\n            originationDate: stripNulls(new Token.StringType(10, 'ascii').get(uint8array, off + 320)).trim(),\n            originationTime: stripNulls(new Token.StringType(8, 'ascii').get(uint8array, off + 330)).trim(),\n            timeReferenceLow: Token.UINT32_LE.get(uint8array, off + 338),\n            timeReferenceHigh: Token.UINT32_LE.get(uint8array, off + 342),\n            version: Token.UINT16_LE.get(uint8array, off + 346),\n            umid: new Token.Uint8ArrayType(64).get(uint8array, off + 348),\n            loudnessValue: Token.UINT16_LE.get(uint8array, off + 412),\n            maxTruePeakLevel: Token.UINT16_LE.get(uint8array, off + 414),\n            maxMomentaryLoudness: Token.UINT16_LE.get(uint8array, off + 416),\n            maxShortTermLoudness: Token.UINT16_LE.get(uint8array, off + 418)\n        };\n    }\n};\n//# sourceMappingURL=BwfChunk.js.map","import * as strtok3 from 'strtok3';\nimport * as Token from 'token-types';\nimport initDebug from 'debug';\nimport * as riff from '../riff/RiffChunk.js';\nimport * as WaveChunk from './WaveChunk.js';\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\nimport * as util from '../common/Util.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { BroadcastAudioExtensionChunk } from './BwfChunk.js';\nimport { WaveContentError } from './WaveChunk.js';\nconst debug = initDebug('music-metadata:parser:RIFF');\n/**\n * Resource Interchange File Format (RIFF) Parser\n *\n * WAVE PCM soundfile format\n *\n * Ref:\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\n * - http://soundfile.sapp.org/doc/WaveFormat\n *\n * ToDo: Split WAVE part from RIFF parser\n */\nexport class WaveParser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.blockAlign = 0;\n    }\n    async parse() {\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n        if (riffHeader.chunkID !== 'RIFF')\n            return; // Not RIFF format\n        this.metadata.setAudioOnly();\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n            if (!(err instanceof strtok3.EndOfStreamError)) {\n                throw err;\n            }\n        });\n    }\n    async parseRiffChunk(chunkSize) {\n        const type = await this.tokenizer.readToken(FourCcToken);\n        this.metadata.setFormat('container', type);\n        switch (type) {\n            case 'WAVE':\n                return this.readWaveChunk(chunkSize - FourCcToken.len);\n            default:\n                throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);\n        }\n    }\n    async readWaveChunk(remaining) {\n        while (remaining >= riff.Header.len) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            remaining -= riff.Header.len + header.chunkSize;\n            if (header.chunkSize > remaining) {\n                this.metadata.addWarning('Data chunk size exceeds file size');\n            }\n            this.header = header;\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n            switch (header.chunkID) {\n                case 'LIST':\n                    await this.parseListTag(header);\n                    break;\n                case 'fact': // extended Format chunk,\n                    this.metadata.setFormat('lossless', false);\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n                    break;\n                case 'fmt ': { // The Util Chunk, non-PCM Formats\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n                    let subFormat = WaveChunk.WaveFormatNameMap[fmt.wFormatTag];\n                    if (!subFormat) {\n                        debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);\n                        subFormat = `non-PCM (${fmt.wFormatTag})`;\n                    }\n                    this.metadata.setFormat('codec', subFormat);\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n                    this.blockAlign = fmt.nBlockAlign;\n                    break;\n                }\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n                case 'ID3 ': { // The way Mp3Tags stores ID3 meta-data\n                    const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n                    const rst = strtok3.fromBuffer(id3_data);\n                    await new ID3v2Parser().parse(this.metadata, rst, this.options);\n                    break;\n                }\n                case 'data': { // PCM-data\n                    if (this.metadata.format.lossless !== false) {\n                        this.metadata.setFormat('lossless', true);\n                    }\n                    let chunkSize = header.chunkSize;\n                    if (this.tokenizer.fileInfo.size) {\n                        const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\n                        if (calcRemaining < chunkSize) {\n                            this.metadata.addWarning('data chunk length exceeding file length');\n                            chunkSize = calcRemaining;\n                        }\n                    }\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign);\n                    if (numberOfSamples) {\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                        if (this.metadata.format.sampleRate) {\n                            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n                        }\n                    }\n                    if (this.metadata.format.codec === 'ADPCM') { // ADPCM is 4 bits lossy encoding resulting in 352kbps\n                        this.metadata.setFormat('bitrate', 352000);\n                    }\n                    else if (this.metadata.format.sampleRate) {\n                        this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\n                    }\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                }\n                case 'bext': { // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\n                    const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);\n                    Object.keys(bext).forEach(key => {\n                        this.metadata.addTag('exif', `bext.${key}`, bext[key]);\n                    });\n                    const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;\n                    await this.tokenizer.ignore(bextRemaining);\n                    break;\n                }\n                case '\\x00\\x00\\x00\\x00': // padding ??\n                    debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                default:\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\n                    await this.tokenizer.ignore(header.chunkSize);\n            }\n            if (this.header.chunkSize % 2 === 1) {\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n                await this.tokenizer.ignore(1);\n            }\n        }\n    }\n    async parseListTag(listHeader) {\n        const listType = await this.tokenizer.readToken(new Token.StringType(4, 'latin1'));\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n        switch (listType) {\n            case 'INFO':\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n            default:\n                this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);\n                debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n        }\n    }\n    async parseRiffInfoTags(chunkSize) {\n        while (chunkSize >= 8) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            const valueToken = new riff.ListInfoTagValue(header);\n            const value = await this.tokenizer.readToken(valueToken);\n            this.addTag(header.chunkID, util.stripNulls(value));\n            chunkSize -= (8 + valueToken.len);\n        }\n        if (chunkSize !== 0) {\n            throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag('exif', id, value);\n    }\n}\n//# sourceMappingURL=WaveParser.js.map"],"names":["Header","buf","off","Token.StringType","Token.UINT32_LE","ListInfoTagValue","tagHeader","WaveContentError","makeUnexpectedFileContentError","WaveFormat","WaveFormatNameMap","Format","header","Token.UINT16_LE","FactChunk","BroadcastAudioExtensionChunk","uint8array","stripNulls","Token.Uint8ArrayType","debug","initDebug","WaveParser","BasicParser","riffHeader","riff.Header","err","strtok3.EndOfStreamError","chunkSize","type","FourCcToken","remaining","WaveChunk.FactChunk","fmt","WaveChunk.Format","subFormat","WaveChunk.WaveFormatNameMap","id3_data","rst","strtok3.fromBuffer","ID3v2Parser","calcRemaining","numberOfSamples","bext","key","bextRemaining","listHeader","listType","valueToken","riff.ListInfoTagValue","value","util.stripNulls","id"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}