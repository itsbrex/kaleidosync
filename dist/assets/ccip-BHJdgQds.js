import{bE as g,bF as O,bG as F,bH as $,bI as q,bJ as L,bK as E,bL as G,bM as m,bN as I,bO as R,bP as T,bQ as D,bR as b,bS as C,bT as w,bU as x,bV as M,bW as H,bX as U,bY as v,bZ as j,b_ as A,b$ as B}from"./index-xeh6oSzU.js";function _(a){const{abi:r,data:e}=a,s=g(e,0,4),t=r.find(n=>n.type==="function"&&s===O(F(n)));if(!t)throw new $(s,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:t.name,args:"inputs"in t&&t.inputs&&t.inputs.length>0?q(t.inputs,g(e,4)):void 0}}const p="/docs/contract/encodeErrorResult";function k(a){const{abi:r,errorName:e,args:s}=a;let t=r[0];if(e){const d=L({abi:r,args:s,name:e});if(!d)throw new E(e,{docsPath:p});t=d}if(t.type!=="error")throw new E(void 0,{docsPath:p});const n=F(t),o=O(n);let c="0x";if(s&&s.length>0){if(!t.inputs)throw new G(t.name,{docsPath:p});c=m(t.inputs,s)}return I([o,c])}const h="/docs/contract/encodeFunctionResult";function J(a){const{abi:r,functionName:e,result:s}=a;let t=r[0];if(e){const o=L({abi:r,name:e});if(!o)throw new R(e,{docsPath:h});t=o}if(t.type!=="function")throw new R(void 0,{docsPath:h});if(!t.outputs)throw new T(t.name,{docsPath:h});const n=(()=>{if(t.outputs.length===0)return[];if(t.outputs.length===1)return[s];if(Array.isArray(s))return s;throw new D(s)})();return m(t.outputs,n)}const N="x-batch-gateway:true";async function P(a){const{data:r,ccipRequest:e}=a,{args:[s]}=_({abi:b,data:r}),t=[],n=[];return await Promise.all(s.map(async(o,c)=>{try{n[c]=o.urls.includes(N)?await P({data:o.data,ccipRequest:e}):await e(o),t[c]=!1}catch(d){t[c]=!0,n[c]=W(d)}})),J({abi:b,functionName:"query",result:[t,n]})}function W(a){return a.name==="HttpRequestError"&&a.status?k({abi:b,errorName:"HttpError",args:[a.status,a.shortMessage]}):k({abi:[C],errorName:"Error",args:["shortMessage"in a?a.shortMessage:a.message]})}class K extends w{constructor({callbackSelector:r,cause:e,data:s,extraData:t,sender:n,urls:o}){super(e.shortMessage||"An error occurred while fetching for an offchain result.",{cause:e,metaMessages:[...e.metaMessages||[],e.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map(c=>`    ${x(c)}`)],`  Sender: ${n}`,`  Data: ${s}`,`  Callback selector: ${r}`,`  Extra data: ${t}`].flat(),name:"OffchainLookupError"})}}class Q extends w{constructor({result:r,url:e}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${x(e)}`,`Response: ${M(r)}`],name:"OffchainLookupResponseMalformedError"})}}class V extends w{constructor({sender:r,to:e}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${e}`,`OffchainLookup sender address: ${r}`],name:"OffchainLookupSenderMismatchError"})}}const z="0x556f1830",X={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function tt(a,{blockNumber:r,blockTag:e,data:s,to:t}){const{args:n}=H({data:s,abi:[X]}),[o,c,d,i,u]=n,{ccipRead:f}=a,y=f&&typeof f?.request=="function"?f.request:Y;try{if(!U(t,o))throw new V({sender:o,to:t});const l=c.includes(N)?await P({data:d,ccipRequest:y}):await y({data:d,sender:o,urls:c}),{data:S}=await v(a,{blockNumber:r,blockTag:e,data:j([i,m([{type:"bytes"},{type:"bytes"}],[l,u])]),to:t});return S}catch(l){throw new K({callbackSelector:i,cause:l,data:s,extraData:u,sender:o,urls:c})}}async function Y({data:a,sender:r,urls:e}){let s=new Error("An unknown error occurred.");for(let t=0;t<e.length;t++){const n=e[t],o=n.includes("{data}")?"GET":"POST",c=o==="POST"?{data:a,sender:r}:void 0,d=o==="POST"?{"Content-Type":"application/json"}:{};try{const i=await fetch(n.replace("{sender}",r.toLowerCase()).replace("{data}",a),{body:JSON.stringify(c),headers:d,method:o});let u;if(i.headers.get("Content-Type")?.startsWith("application/json")?u=(await i.json()).data:u=await i.text(),!i.ok){s=new A({body:c,details:u?.error?M(u.error):i.statusText,headers:i.headers,status:i.status,url:n});continue}if(!B(u)){s=new Q({result:u,url:n});continue}return u}catch(i){s=new A({body:c,details:i.message,url:n})}}throw s}export{Y as ccipRequest,tt as offchainLookup,X as offchainLookupAbiItem,z as offchainLookupSignature};
//# sourceMappingURL=ccip-BHJdgQds.js.map
