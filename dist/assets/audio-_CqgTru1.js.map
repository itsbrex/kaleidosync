{"version":3,"mappings":"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","names":["sessionLogger","loadSessionLogger","useSessionLogger","__vitePreload","error","useAudio","defineStore","audioElement","ref","src","currentTrackId","toast","useToast","lastToastTrackId","checkForElement","element","audioSystem","interval","mediaControls","useMediaControls","currentTime","duration","playing","waiting","ended","mediaVolume","muted","enableTrack","play","success","logger","pause","initializeAnalyser","volume","stream","cleanupAnalyser","analyserInitialized","useAudioAnalyser","raf","useRAF","now","result","initialized","isLoading","userGestureInitialized","computed","state","currentPosition","audioDuration","progress","setSource","url","seek","seconds","skip","newTime","setVolume","level","initializeAudio","audioContext","analyserNode","getAudioUrlForTrack","track","AudioSource","audiusTrackId","showNowPlayingToast","message","updateMediaSessionMetadata","useSources","n","mediaConfig","art","playTrack","audioUrl","trackId","response","api","streamUrl","watch","trackEnded","useQueue","queue","handleCanPlay","handleLoadStart","cleanup"],"ignoreList":[0],"sources":["../../node_modules/@wearesage/vue/src/stores/audio.ts"],"sourcesContent":["import { ref, computed, watch } from \"vue\";\nimport { defineStore, acceptHMRUpdate } from \"pinia\";\nimport { useMediaControls } from \"@vueuse/core\";\nimport { audioSystem } from \"../classes/AudioSystemManager\";\nimport { useAudioAnalyser } from \"../composables/audio/useAudioAnalyser\";\nimport { useRAF } from \"./raf\";\nimport { useToast } from \"./toast\";\nimport { AudioSource } from \"@wearesage/shared\";\nimport { api } from \"../api/client\";\n\n// Session logging integration\nlet sessionLogger: any = null;\nconst loadSessionLogger = async () => {\n  if (!sessionLogger) {\n    try {\n      const { useSessionLogger } = await import('./session-logger');\n      sessionLogger = useSessionLogger();\n    } catch (error) {\n      console.warn('Session logger not available:', error);\n    }\n  }\n  return sessionLogger;\n};\n\nexport const useAudio = defineStore(\"audio\", () => {\n  // Audio element and source (managed by AudioSystemManager)\n  const audioElement = ref<HTMLAudioElement>();\n  const src = ref<string>(\"\");\n  const currentTrackId = ref<string | null>(null);\n  \n  // Toast for \"Now Playing\" notifications\n  const toast = useToast();\n  const lastToastTrackId = ref<string | null>(null);\n  \n  // Get element from audio system manager\n  if (typeof window !== 'undefined') {\n    // Element will be created when user gesture happens\n    const checkForElement = () => {\n      const element = audioSystem.getAudioElement();\n      if (element && !audioElement.value) {\n        audioElement.value = element;\n        console.log('ðŸŽµ Audio element acquired from AudioSystemManager');\n      }\n    };\n    \n    // Check immediately and set up interval for when gesture happens\n    checkForElement();\n    const interval = setInterval(() => {\n      checkForElement();\n      if (audioElement.value) {\n        clearInterval(interval);\n      }\n    }, 100);\n  }\n\n  // Use VueUse media controls for comprehensive audio management\n  const mediaControls = useMediaControls(audioElement, {\n    src,\n  });\n\n  // Destructure with safer access\n  const {\n    currentTime,\n    duration,\n    playing,\n    waiting,\n    ended,\n    volume: mediaVolume,\n    muted,\n    enableTrack,\n  } = mediaControls;\n\n  // Use AudioSystemManager for bulletproof play/pause\n  const play = async () => {\n    console.log('ðŸ”Š Attempting to play audio...');\n    const success = await audioSystem.playAudio();\n    if (success) {\n      console.log('ðŸ”Š Audio playing via AudioSystemManager');\n      \n      // Log audio resume event\n      const logger = await loadSessionLogger();\n      if (logger && currentTrackId.value) {\n        logger.logEvent(logger.SessionEventType.AUDIO_RESUME, {\n          trackId: currentTrackId.value,\n          currentTime: currentTime.value,\n          timestamp: Date.now()\n        });\n      }\n    } else {\n      console.warn('ðŸ”Š AudioSystemManager playAudio() returned false');\n    }\n    return success;\n  };\n\n  const pause = async () => {\n    audioSystem.pauseAudio();\n    \n    // Log audio pause event\n    const logger = await loadSessionLogger();\n    if (logger && currentTrackId.value) {\n      logger.logEvent(logger.SessionEventType.AUDIO_PAUSE, {\n        trackId: currentTrackId.value,\n        currentTime: currentTime.value,\n        timestamp: Date.now()\n      });\n    }\n  };\n\n  // Audio analysis using the SAUCE (useAudioAnalyser + AudioSystemManager)\n  const { initialize: initializeAnalyser, volume, stream, cleanup: cleanupAnalyser, initialized: analyserInitialized } = useAudioAnalyser();\n  \n  // RAF loop for continuous audio analysis (runs regardless of audio element state)\n  const raf = useRAF();\n  raf.add((now) => {\n    if (analyserInitialized.value) {\n      const result = audioSystem.tick(raf.frameRate);\n      volume.value = result.volume;\n      stream.value = result.stream;\n    }\n  }, { id: 'audio-analysis' });\n  \n  const initialized = ref(false);\n  const isLoading = ref(false);\n  \n  // Track if audio system is initialized\n  const userGestureInitialized = computed(() => {\n    const state = audioSystem.getState();\n    return state.isPrimed && state.hasUserGesture;\n  });\n\n  // Convert to milliseconds for consistency with old API\n  const currentPosition = computed(() => currentTime.value * 1000);\n  const audioDuration = computed(() => duration.value * 1000);\n\n  // Progress tracking (0-1)\n  const progress = computed(() => {\n    return duration.value > 0 ? currentTime.value / duration.value : 0;\n  });\n\n  /**\n   * Set audio source URL using AudioSystemManager\n   */\n  function setSource(url: string) {\n    console.log(\"ðŸ”Š Setting audio source:\", url);\n    isLoading.value = true; // Start loading\n    src.value = url;\n    audioSystem.setAudioSource(url);\n  }\n\n  /**\n   * Seek to specific position (in seconds)\n   */\n  function seek(seconds: number) {\n    currentTime.value = seconds;\n  }\n\n  /**\n   * Skip forward/backward by specified seconds\n   */\n  function skip(seconds: number) {\n    const newTime = Math.max(0, Math.min(currentTime.value + seconds, duration.value || 0));\n    seek(newTime);\n  }\n\n  /**\n   * Set volume (0-1)\n   */\n  function setVolume(level: number) {\n    mediaVolume.value = Math.max(0, Math.min(1, level));\n  }\n\n  /**\n   * Initialize audio with user gesture using AudioSystemManager + AudioAnalyser\n   * Must be called synchronously within a user interaction event\n   */\n  async function initializeAudio() {\n    if (userGestureInitialized.value) {\n      console.log(\"ðŸ”Š Audio already initialized via AudioSystemManager\");\n      return true;\n    }\n\n    try {\n      console.log(\"ðŸ”Š Initializing audio system with user gesture...\");\n      \n      // Prime the audio system synchronously\n      const success = audioSystem.primeAudioSystem();\n      \n      if (success) {\n        // Get the primed audio element and context\n        audioElement.value = audioSystem.getAudioElement();\n        const audioContext = audioSystem.getAudioContext();\n        const analyserNode = audioSystem.getAnalyserNode();\n        \n        if (audioElement.value) {\n          // Initialize the consolidated AudioSystemManager for audio element\n          await initializeAnalyser(audioElement.value);\n          \n          initialized.value = true;\n          console.log(\"ðŸ”Š Audio system + AudioAnalyser initialized successfully!\");\n          return true;\n        } else {\n          console.warn(\"ðŸ”Š Missing audio components from AudioSystemManager\");\n          return false;\n        }\n      } else {\n        console.warn(\"ðŸ”Š Failed to prime audio system\");\n        return false;\n      }\n    } catch (error) {\n      console.error(\"ðŸ”Š Failed to initialize audio system:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Get audio URL for a queue track based on its source\n   */\n  function getAudioUrlForTrack(track: any): string | null {\n    if (!track) return null;\n\n    switch (track.source) {\n      case AudioSource.SPOTIFY:\n        // Spotify requires premium and Web Playback SDK - return null for now\n        console.warn(\"ðŸ”Š Spotify playback requires Web Playback SDK integration\");\n        return null;\n\n      case AudioSource.AUDIUS:\n        // Audius requires a separate API call to get the stream URL\n        // We need to get the track ID and make a request to our API\n        const audiusTrackId = track.rawData?.id || track.rawData?.audiusId || track.sourceId;\n\n        if (audiusTrackId) {\n          console.log(\"ðŸ”Š Audius track ID:\", audiusTrackId);\n          // Return a special marker that we'll handle in playTrack()\n          return `audius-stream:${audiusTrackId}`;\n        }\n\n        console.warn(\"ðŸ”Š No track ID found for Audius track:\", track);\n        console.warn(\"ðŸ”Š Available rawData fields:\", Object.keys(track.rawData || {}));\n        return null;\n\n      case AudioSource.RADIO_PARADISE:\n      case AudioSource.KEXP:\n        // Radio stations - would need live stream URLs\n        console.warn(\"ðŸ”Š Radio playback not yet implemented\");\n        return null;\n\n      case AudioSource.FILE:\n        // File source should have a direct URL\n        return track.rawData?.url || track.sourceId;\n\n      default:\n        console.warn(\"ðŸ”Š Unknown audio source:\", track.source);\n        return null;\n    }\n  }\n\n  /**\n   * Show \"Now Playing\" toast notification\n   */\n  function showNowPlayingToast(track: any) {\n    if (!track || track.id === lastToastTrackId.value) return;\n    \n    console.log('ðŸŽµ Now Playing:', track.title, 'by', track.artist);\n    \n    const message = `ðŸŽµ Now Playing: \"${track.title}\" by ${track.artist}`;\n    toast.message(message);\n    \n    lastToastTrackId.value = track.id;\n  }\n\n  /**\n   * Update media session metadata for the currently loaded track\n   */\n  async function updateMediaSessionMetadata(track: any) {\n    if (!track) {\n      // Clear metadata if no track\n      if ('mediaSession' in navigator) {\n        navigator.mediaSession.metadata = null;\n      }\n      return;\n    }\n\n    try {\n      // Check if the current source supports metadata\n      const { useSources } = await import('./sources');\n      const sources = useSources();\n      const mediaConfig = sources.mediaSessionManager.getCurrentConfig();\n      \n      // Only update metadata if current source has media session enabled and supports metadata\n      if (!mediaConfig?.enabled || !mediaConfig.metadata) {\n        console.log('ðŸŽµ Skipping metadata update - current source does not support metadata');\n        return;\n      }\n\n      // Use enableTrack if available and audio is properly initialized\n      if (typeof enableTrack === 'function' && audioElement.value && userGestureInitialized.value) {\n        enableTrack({\n          title: track.title,\n          artist: track.artist,\n          album: track.album || '',\n          artwork: track.artwork ? [\n            { src: track.artwork.small || '', sizes: '64x64', type: 'image/jpeg' },\n            { src: track.artwork.medium || '', sizes: '300x300', type: 'image/jpeg' },\n            { src: track.artwork.large || '', sizes: '640x640', type: 'image/jpeg' },\n          ].filter(art => art.src) : [],\n        });\n\n        console.log('ðŸŽµ Updated track metadata via useMediaControls for:', track.title);\n      } else {\n        // Fallback to manual Media Session API\n        if ('mediaSession' in navigator) {\n          navigator.mediaSession.metadata = new MediaMetadata({\n            title: track.title,\n            artist: track.artist,\n            album: track.album || '',\n            artwork: track.artwork ? [\n              { src: track.artwork.small || '', sizes: '64x64', type: 'image/jpeg' },\n              { src: track.artwork.medium || '', sizes: '300x300', type: 'image/jpeg' },\n              { src: track.artwork.large || '', sizes: '640x640', type: 'image/jpeg' },\n            ].filter(art => art.src) : [],\n          });\n          console.log('ðŸŽµ Updated track metadata via fallback Media Session API for:', track.title);\n        }\n      }\n    } catch (error) {\n      console.warn('Could not update media session metadata:', error);\n    }\n  }\n\n  /**\n   * Load and play a queue track\n   */\n  async function playTrack(track: any) {\n    // Ensure audio is initialized before playing\n    if (!userGestureInitialized.value) {\n      console.log(\"ðŸ”Š Audio not initialized, initializing now...\");\n      const initSuccess = initializeAudio();\n      if (!initSuccess) {\n        console.error(\"ðŸ”Š Failed to initialize audio\");\n        return false;\n      }\n    }\n\n    const audioUrl = getAudioUrlForTrack(track);\n\n    if (!audioUrl) {\n      console.error(\"ðŸ”Š No playable audio URL for track:\", track);\n      // No fallback - just return false\n      return false;\n    }\n\n    console.log(\"ðŸ”Š Loading track:\", track.title, \"by\", track.artist);\n\n    // Update current track ID for duplicate prevention\n    currentTrackId.value = track.sourceId;\n    \n    // Log track start event\n    const logger = await loadSessionLogger();\n    if (logger) {\n      logger.logEvent(logger.SessionEventType.AUDIO_TRACK_START, {\n        trackId: track.sourceId,\n        title: track.title,\n        artist: track.artist,\n        album: track.album,\n        source: track.source,\n        duration: track.duration,\n        timestamp: Date.now()\n      });\n    }\n\n    // Handle Audius stream URL fetching\n    if (audioUrl.startsWith(\"audius-stream:\")) {\n      const trackId = audioUrl.replace(\"audius-stream:\", \"\");\n\n      try {\n        console.log(\"ðŸ”Š Fetching Audius stream URL for track ID:\", trackId);\n\n        // Call our API to get the stream URL using authenticated client\n        const response = await api.get(`/api/audius/stream/${trackId}`);\n        const { url: streamUrl } = response.data;\n\n        if (streamUrl) {\n          console.log(\"ðŸ”Š Got Audius stream URL:\", streamUrl);\n          setSource(streamUrl);\n          \n          // Update media session metadata now that we're loading this track\n          await updateMediaSessionMetadata(track);\n          \n          // Show \"Now Playing\" toast\n          showNowPlayingToast(track);\n        } else {\n          throw new Error(\"No stream URL returned\");\n        }\n      } catch (error) {\n        console.error(\"ðŸ”Š Failed to fetch Audius stream URL:\", error);\n        // Clear current track ID on error\n        currentTrackId.value = null;\n        // No fallback - just return false\n        return false;\n      }\n    } else {\n      // Regular URL, use directly\n      setSource(audioUrl);\n      \n      // Update media session metadata now that we're loading this track\n      await updateMediaSessionMetadata(track);\n      \n      // Show \"Now Playing\" toast\n      showNowPlayingToast(track);\n    }\n\n    // Autoplay is enabled on the audio element, so just setting src should trigger playback\n    console.log('ðŸ”Š Track loaded with autoplay enabled');\n    return true;\n  }\n\n  // Watch for track end to auto-advance\n  watch(\n    ended,\n    (trackEnded) => {\n      if (trackEnded) {\n        console.log(\"ðŸ”Š Track ended\");\n\n        // Try to get queue store for automatic progression\n        import(\"./queue\")\n          .then(({ useQueue }) => {\n            const queue = useQueue();\n\n            // Auto-advance to next track if available\n            if (queue.hasNext) {\n              console.log(\"ðŸ”Š Auto-advancing to next track\");\n              queue.nextTrack();\n            } else {\n              console.log(\"ðŸ”Š End of queue reached\");\n            }\n          })\n          .catch((error) => {\n            console.warn(\"Could not auto-advance track:\", error);\n          });\n      }\n    }\n  );\n\n  // Watch for audio element from AudioSystemManager\n  watch(\n    audioElement,\n    async (element) => {\n      if (element && !initialized.value) {\n        console.log(\"ðŸ”Š Audio element connected from AudioSystemManager\");\n        \n        // Initialize with consolidated AudioSystemManager\n        await initializeAnalyser(element);\n        initialized.value = true;\n        \n        // Set up loading state event listeners\n        const handleCanPlay = () => {\n          console.log(\"ðŸ”Š Audio can play - loading complete\");\n          isLoading.value = false;\n        };\n        \n        const handleLoadStart = () => {\n          console.log(\"ðŸ”Š Audio load started\");\n          isLoading.value = true;\n        };\n        \n        // Add event listeners for loading state\n        element.addEventListener('loadstart', handleLoadStart);\n        element.addEventListener('canplay', handleCanPlay);\n        element.addEventListener('playing', handleCanPlay);\n        \n        // Clean up event listeners when element changes\n        const cleanup = () => {\n          element.removeEventListener('loadstart', handleLoadStart);\n          element.removeEventListener('canplay', handleCanPlay);\n          element.removeEventListener('playing', handleCanPlay);\n        };\n        \n        // Store cleanup function for later use\n        (element as any)._audioLoadingCleanup = cleanup;\n      }\n    },\n    { immediate: true }\n  );\n\n  return {\n    // Core audio element (from useMediaControls)\n    element: audioElement,\n\n    // Audio state (from useMediaControls)\n    src,\n    playing,\n    currentPosition,\n    duration: audioDuration,\n    progress,\n    waiting,\n    ended,\n    muted,\n    isLoading,\n\n    // Audio analysis (from useAudioAnalyser - the SAUCE!)\n    volume, // Sophisticated volume analysis with smoothing\n    stream, // Stream animation with proper scaling\n    initialized: computed(() => initialized.value && analyserInitialized.value),\n    userGestureInitialized,\n\n    // Controls (from useMediaControls)\n    play,\n    pause,\n    toggle: () => playing.value ? pause() : play(), // Add toggle for compatibility\n    seek,\n    skip,\n    setVolume,\n\n    // Media Session API (from useMediaControls)\n    enableTrack,\n\n    // Queue integration\n    setSource,\n    playTrack,\n    getAudioUrlForTrack,\n    initializeAudio,\n    currentTrackId,\n    updateMediaSessionMetadata,\n    showNowPlayingToast,\n  };\n});\n\nif (import.meta.hot) {\n  import.meta.hot.accept(acceptHMRUpdate(useAudio, import.meta.hot));\n}\n"],"file":"assets/audio-_CqgTru1.js"}